# Classes

## 3- Defining a Class

- Rectangle.h

```cpp
class Rectangle {
    int width;
    int height;
    void draw();
    int getArea();
}
```

- Rectangle.cpp

```cpp
# include "Rectangle.h"
# include <iostream>

using namespace std;

void Rectangle::draw() {
    cout << "Drawing a rectangle" << endl;
    cout << "Demensions: " << width << ", " << height << endl;
}

int Rectangle::getArea() {
    return width * height;
}
```

## 4- Creating Objects

- class 与 structure 的不同：in structure, when we declaire a members, the members are always public to outside BY DEFAULT

```cpp
#include "Rectangle.h"

int main() {
    return 0;
}
```

- Rectangle.h

```cpp
class Rectangle {
public:
    int width;
    int height;
    void draw();
    int getArea();
}
```

## 6- Getters and Setters

```cpp
# include "Rectangle.h"
# include <iostream>

using namespace std;

void Rectangle::setWidth(int width) {
    if (width < 0)
        throw invalid_argument("width");
    (*this).width = width;
    this->width = width;
    Rectangle::width = width;
}
```

## 8- Member Initializer List

- 代替在构造函数中初始化这两个值，可以直接像以下这样写。
- 这样写不能 call setter，只能是最简化的初始化

```cpp
# include "Rectangle.h"
# include <iostream>

using namespace std;

Rectangle::Rectangle(int width, int height) : width{width}, height{height} {

}
```

## 9- The Default Constructor

- Rectangle() = default;
- 这就是默认构造函数
- 它没有参数
- = default 的意思是各项成员设成 default 值，height，width 都为 0
- 如果不写这个，cpp 会自动生成这种默认构造函数

```cpp
class Rectangle {
public:
    Rectangle() = default;
    Rectangle(int width, int height);
    void draw();
    int getArea();
private:
    int width = 0;
    int height = 0;
}
```

## 10- Using the Explicit Keyword

- 在构造函数前添加 explicit 关键字, 就无法将只包含一个参数的构造函数, 利用传递 int, 自动生成一个 Person 类

```cpp
class Person {
public:
    // converting constructor
    Person(int age);
private:
    int age;
}

void showPerson(Person person) {
    ...
}

int main() {
    Person person(20);
    Person person{20};
    showPerson(person);
    showPerson(20);
}
```

## 11- Constructor Delegation 代表团

```cpp
Rectangle::Rectangle(int width, int height, const string &color) : Rectangle(width, height) {
    // 以下两句就不用写了，因为已经在 Rectangle(width, height) 中写过了
    // setWidth(width);
    // setHeight(height);
    this->color = color;
}
```

## 12- The Copy Constructor

```cpp
Rectangle fitst{10, 20};
Rectangle second = first;
// 当以上情况出现，就会调用Rectangle的copy constructor
```

- const Rectangle&: 确保不修改原本的 Rectangle

<img decoding="async" src="Classes-12- The Copy Constructor.png" width="400px" style="display:block;">

```cpp
void showRectangle(Rectangle rectangle) {

}

int main() {
    Rectangle first{10, 20};
    // Constructing a Rectangle
    // Rectangle copies
    showRectangle(first);

    return 0;
}

void showRectangle(Rectangle& rectangle) {

}

int main() {
    Rectangle first{10, 20};
    // Constructing a Rectangle
    // reference parameter, a rectangle is not copied, the source object is passed to the show rectangle
    showRectangle(first);

    return 0;
}
```

- 如果我们想阻止 copy 的行为，我们可以在 head 文件中：Rectangle(const Rectangle& source) = delete;

## 13- The Destructor

- destructors are automatically called when our object are being destroyed
- 这是一个解放这个 object 使用的系统资源的机会
- Rectangle 没有使用任何系统资源，比如说 memory file
- ~Rectanle()
- 当 main 结束的时候，first object 就会 out of scope, 就会自动 call destructor

## 14- Static Members

- private: static int objectsCount;
- int Rectangle::objectsCount = 0;
- int Rectangle::getObjectCount() { return objectsCount }

## 16- Pointer to Objects

- 目前所有 rectangle 的 object 都是存在 stack 上的，这会自动清理，当 out of scope 的时候
- 我们不想 main 结束就删除 object
- 需要把它存在 heap 上
- 利用 new 关键字

```cpp
int main() {
    auto rectangle = new Rectangle(10, 20);
    rectangle->draw();
    delete rectangle;
    rectangle = nullptr;

    return 0;
}
```

- 最好不用利用上述办法，很容易忘记 delete。可以使用 smart pointer

```cpp
int main() {
    auto rectangle = make_unique<Rectangle>(10, 20);
    rectangle->draw();

    return 0;
}
```

# Operator Overloading

## 2- Overloading the Equality Operator

- Operator Overloading: to implement the built in operators

```cpp
bool operator==(const lenght& other) const;
bool operator==(int other) const;
bool operato!=(int other) const;

bool Length::operator==(const Length &other) const {
    return value == other.value;
}
bool Length::operator==(int other) const {
    return value == other;
}
bool Length::operator!=(int other) const {
    return !(value == other);
}
```

## 4- Overloading the Spaceship Operator

```cpp
// Length.h
public: strong_ordering operater<=>(const Length& other) const;

// Length.cpp
std::strong_ordering Length::operator<=>(const Length &other){
    return value <=> other.value;
}

// main.cpp
int main() {
    int x = 10;
    int y = 20;
    auto result = x <=> y;

    if (result == strong_ordering::less) {}
    if (result == strong_ordering::greater) {}
    else {}
}
```

## 5- Overloading the Stream Insertion Operator

```cpp
// Length.h
ostream& operator<<(ostream& stream, const Lenght& length);

// Length.cpp
ostream &operator<<(ostream &stream, const Lenght &length) {
    stream << length.getValue();
    return stream;
}
```

## 7- Friends of Classes

如果一个 private 变量，没有 getter or setter。外部的方法想要访问，可以将外部方法在 private 部分利用关键字 friend 声明。外部方法就可以访问 private 了

## 10- Overloading the Assignment Operator

- public: strong_ordering operater<=>(const Length& other) const;
  - 结尾处的 const 代表着，整个方法不会修改本 instance

## 12- Overloading the Subscript Operator

- 如果有一个 class，类似 array / collection，我们就可以 implement the subscript operator to provide access to individual elements in that class

- Array.h
  - cstddef - c standard defination - for size_t

```cpp

#define ADVANCED_ARRAY_H

#include <cstddef>

class Array{
public:
    explicit Array(size_t size);
    ~Arrray();
    int& operator[](size_t index);
private:
    int* values;
    size_t size;
}

#endif //ADVANCED_ARRAY_H
```

- Array.cpp

```cpp
#include <stdexcept>
#include "Array.h"

Array::Array(size_t size) {
    // int* values = new int[size];
    // 因为我们动态的 allocate memory in this constructor，所以我们需要释放它 in the destructor
    values = new int[size];
    this->size = size;
}

Array::~Array() {
    delete[] values;
}

int& Array::operator[](size_t index) {
    if (index >= size)
        throw std::invalid_argument("index");

    return values[index];
}
```

- main.cpp

```cpp
#include <iostream>
#include "Array.h"

using namespace std;

int main() {
    Array array{10};
    array[0] = 1;
    cout << array[0];

    // 下面会报错，因为超过index了
    Array array{10};
    array[10] = 1;
    cout << array[10];

    return 0;
}

```

## 13- Overloading the Indirection Operator

- 返回值是引用，int&, 因为 we will be acccessing an existing integer in the memory

- SmartPointer.h

```cpp
class SmartPointer {
public:
    explicit SmartPointer(int* ptr);
    ~SmartPointer();
    int& operator*();
private:
    int* ptr;
}
```

- SmartPointer.cpp

```cpp
int& SmartPointer::operator*() {
    return *ptr;
}
```

- main.cpp

```cpp
#include <iostream>
#include "SmartPointer.h"

using namespace std;

int main() {
    SmartPointer ptr{new int};
    *ptr = 100;
    cout << *ptr << endl;
    *ptr = 101;
    cout << *ptr;

    return 0;
}

```

# Inheritance and Polymorphism

## 2- Inheritance

- public Widget: the public members of the class will be inherited as public, so we can access them outside of the textbox class
- private Widget: the private members of the class will become private in the textbox class

## 3- Protected Members

- protected vs private: protected members are visible within derived class, but private members are not

## 4- Constructors and Inheritance

<img decoding="async" src="Inheritance and Polymorphism-4- Constructors and Inheritance.png" width="500px" style="display:block;">

```cpp
TextBox::TextBox(bool enabled, const string &value): Widget(enabled), value{value} {

}
```

## 9- Polymorphic Collections

- static or early binding: the compiler matches a function call with the proper definition of that function at compile time
- 结果是两次 Drawing a Widget

<img decoding="async" src="Inheritance and Polymorphism-9- Polymorphic Collections.png" width="500px" style="display:block;">

- dynamic or late binding: we want the compiler to match the function call with the right function at runtime
- 结果是 drawing a textbox and drawing a checkbox

<img decoding="async" src="Inheritance and Polymorphism-9- Polymorphic Collections-2.png" width="500px" style="display:block;">

- smart pointer

<img decoding="async" src="Inheritance and Polymorphism-9- Polymorphic Collections-3.png" width="500px" style="display:block;">

## 10- Virtual Destructors

- declare a method in a class as virtual, that means you're going to use polymorphism at some point
- when you use polymorphism, you have to make sure that your objects are destroyed properly
- whenever you declare a method as virtual, you should always add a virtual destructor in that class as well

## 11- Abstract Classes

- pure virtual method, 当一个类包含了这种方法，这个类就是 abstract 的，不能被实例化
- virtual void draw() const = 0;

## 12- Final Classes and Methods

<img decoding="async" src="Inheritance and Polymorphism-12- Final Classes and Methods.png" width="500px" style="display:block;">

## 14- Multiple Inheritance

- 同样名字的父类方法，子类继承的时候，需要指定父类名字

# Exceptions

## 8- Creating Custom Exceptions

<img decoding="async" src="Exceptions-8- Creating Custom Exceptions.png" width="500px" style="display:block;">

<img decoding="async" src="Exceptions-8- Creating Custom Exceptions-1.png" width="200px" style="display:block;">

<img decoding="async" src="Exceptions-8- Creating Custom Exceptions-2.png" width="300px" style="display:block;">

# Templates

## 2- Defining a Function Template

- with function templates, potentially, the size of our executable or application can be smaller
- so if we don't call this function anywhere in our code, the compiler is not going to generate instances of this function template in our executable.
- so this is not going to be included in our executable
- 如果我们 call 这个 function，compiler 就会 generate an instance of this template that takes two double values
- 如果再次 call 它，compiler 不会从新 generate an instance that takes two doubles. it will reuse the instance that it generated for this line

<img decoding="async" src="Templates-2- Defining a Function Template.png" width="500px" style="display:block;">

## 4- Templates with Multiple Parameters

<img decoding="async" src="Templates-4- Templates with Multiple Parameters.png" width="400px" style="display:block;">
