# Arrays

## 2- Creating and Initializing Arrays

<img decoding="async" src="Arrays-2- Creating and Initializing Arrays.png" width="300px" style="display:block;">

<img decoding="async" src="Arrays-2- Creating and Initializing Arrays-2.png" width="400px" style="display:block;">

- 直接打印 array 本身, 而非某个 index 的值, 我们会得到这个 array 在内存的地址, 是一个 16 进制的数

## 3- Determining the Size of Arrays

<img decoding="async" src="Arrays-3- Determining the Size of Arrays-2.png" width="400px" style="display:block;">

<img decoding="async" src="Arrays-3- Determining the Size of Arrays.png" width="400px" style="display:block;">

## 4- Copying Arrays

- 我们不可以只用一个 array，初始化另一个 array
- 我们不可以将一个 array，赋值给另一个 array

<img decoding="async" src="Arrays-4- Copying Arrays.png" width="400px" style="display:block;">

## 5- Comparing Arrays

- 如果直接比较，always false，因为会对比两个 array 的内存地址

<img decoding="async" src="Arrays-5- Comparing Arrays.png" width="400px" style="display:block;">

## 6- Passing Arrays to Functions

- 下面这部分，实际发生的是，一个 int array，被转化成了一个 int pointer
- int pointer, 实际是这个 array 的内存地址
- 以下都会编译错误, 直接使用 numbers 都会编译错误：
  - for(int number: numbers)
  - for(int i = 0; i < size(numbers); i++)

<img decoding="async" src="Arrays-6- Passing Arrays to Functions.png" width="400px" style="display:block;">

- 不只要传递 array，还要传递它的 size

<img decoding="async" src="Arrays-6- Passing Arrays to Functions-2.png" width="400px" style="display:block;">

## 7- Understanding size_t

- sizeof()：返回一个值，这个值的类型是 size_t，t is short for type
- size t is a type, or a datatype defined in the standard library that is used for representing the size of object is guaranteed to be large enough to contain the size of the largest object the system can handle
- size t 是一种类型，或者是标准库中定义的数据类型，用于表示对象的大小，保证足够大以包含系统可以处理的最大对象的大小
- 4 and 8

<img decoding="async" src="Arrays-7- Understanding size_t.png" width="300px" style="display:block;">

<img decoding="async" src="Arrays-7- Understanding size_t-2.png" width="500px" style="display:block;">

<img decoding="async" src="Arrays-7- Understanding size_t-3.png" width="200px" style="display:block;">

size_t 是 C++ 中的一种数据类型，用来表示任何对象的大小。这个类型是无符号的整型，其大小足以容纳内存中可寻址的最大对象的字节大小。通常，在包含标准库头文件如 <cstddef> 或 <cstring> 之后，你可以使用 size_t。

在 C++ 中，size_t 的主要用途包括：

    数组索引：因为数组的大小不可能是负数，使用 size_t 作为索引类型可以确保索引值总是非负的。
    循环计数：在循环遍历数据结构，如数组或向量时，size_t 常用于计数循环迭代。
    内存管理：在动态分配内存（例如，使用 malloc 或 new[]）时，size_t 用于指定要分配的字节数。
    字符串和数组操作：标准库中的很多函数（如 strlen 或 memcpy）使用 size_t 来指定字节数或元素数。

使用 size_t 的一个优点是它能适应不同平台上的内存模型。例如，在 32 位系统上，size_t 通常是 32 位的，而在 64 位系统上则是 64 位的。这样可以帮助保证程序在不同的架构上具有良好的可移植性。

## 8- Unpacking Arrays

<img decoding="async" src="Arrays-8- Unpacking Arrays.png" width="400px" style="display:block;">

## 9- Searching Arrays

<img decoding="async" src="Arrays-9- Searching Arrays.png" width="400px" style="display:block;">

<img decoding="async" src="Arrays-9- Searching Arrays-1.png" width="500px" style="display:block;">

## 10- Sorting Arrays

- bubble sort
- selection sort
- insertion sort
- merge sort
- quick sort

<img decoding="async" src="Arrays-10- Sorting Arrays.png" width="400px" style="display:block;">

<img decoding="async" src="Arrays-10- Sorting Arrays-2.png" width="400px" style="display:block;">

## 11- Multi-dimensional Arrays

<img decoding="async" src="Arrays-11- Multi-dimensional Arrays-2.png" width="200px" style="display:block;">

<img decoding="async" src="Arrays-11- Multi-dimensional Arrays.png" width="400px" style="display:block;">

<img decoding="async" src="Arrays-11- Multi-dimensional Arrays-1.png" width="400px" style="display:block;">

# Pointers

## 3- Declaring and Using Pointers

- 如果指针变量没有初始化，我们会有一个问题，we might end up accessing a part of memory we are not supposed to. and in that case, the operating system is going to terminate our program and say, memory access voilation. 所以，我们最好初始化一个指针变量
  - int\* ptr = nullptr;

<img decoding="async" src="Pointers-3- Declaring and Using Pointers.png" width="400px" style="display:block;">

## 4- Constant Pointers

- pointers & constants

  - data is constant: pointer may point to somewhere else later
  - pointer is constant: 不能指向别处
  - both data and pointer are constant

- 场景一: data is constant

```cpp
// 以下会有错误, 因为我们不可以将一个 int 类型 的pointer, 指向常量
// we cannot have an integer pointer point to a constant integer
const int x = 10;
int* ptr = &x;

// 必须加上 const int*
// 这种情况下, int x 是常量, 但是 pointer 不是的, 它可以指向另一个地方
const int x = 10;
const int* ptr = &x;
```

- 要指向常量，必须是 const int*，const int*的数据内容不可被修改，但是指向的位置可以被修改

<img decoding="async" src="Pointers-4- Constant Pointers.png" width="200px" style="display:block;">

- 可以将 pointer 指向另一个位置:

<img decoding="async" src="Pointers-4- Constant Pointers-1.png" width="200px" style="display:block;">

- 场景二: pointer is constant
  - 如果想要指针指向不可被修改，应该使用 int\* const ptr
  - 对于 int\* const ptr，我们 always 需要初始化它，否则会有编译错误

<img decoding="async" src="Pointers-4- Constant Pointers-2.png" width="200px" style="display:block;">

- 场景三: both data and pointer are constant

```cpp
const int x = 10;
const int* const ptr = &x;
```

## 5- Passing Pointers to Functions

- 引用传递是一种现代的，更推荐的方法。void increasePrice(double& price). 参考 1 中引用传递
- 使用指针传递参数也可以，但是会需要更多工作量，也更复杂

<img decoding="async" src="Pointers-5- Passing Pointers to Functions.png" width="400px" style="display:block;">

## 6- The Relationship Between Arrays and Pointers

```C++
int numbers[] = {10, 20, 30};
cout << numbers;
// 16进制地址码
cout << *numbers;
// 10

int numbers[] = {10, 20, 30};
int* ptr = numbers;
cout << ptr;
// 16进制地址码
cout << *ptr;
// 10
cout << ptr[1];
// 20
```

## 7- Pointer Arithmetic 算术

```C++
int numbers[] = {10, 20, 30};
int* ptr = numbers;
// ptr = 100-103
// sizeof(data) sizeof(int)
// ptr++ = 104
ptr++
cout << *ptr;
// 20
cout << *(ptr + 1);
// 20
cout << ptr[1];
cout << numbers[1];
```

## 8- Comparing Pointers

```C++
int x = 10;
int y = 20;

int* ptrX = &x;
int* ptrY = &y;

if(*ptrX < *ptrY)

// compare address
if(ptrX == ptrY)
    cout << "Same";

if (ptrX != nullptr)
    cout << *ptrX;
```

- 反向打印 array

<img decoding="async" src="Pointers-8- Comparing Pointers.png" width="400px" style="display:block;">

## 9- Dynamic Memory Allocation

- 在 stack 中新建的变量, 如果 out of scope, 会自动释放内存. 不需要清理, 会自动被清理

<img decoding="async" src="Pointers-9- Dynamic Memory Allocation.png" width="300px" style="display:block;">

- 我们必须自己 delete, 否则程序会占用越来越多的内存, 会崩溃, 会出现 memory leak
- why not mandatory it's always a good practice to reset these pointers

<img decoding="async" src="Pointers-9- Dynamic Memory Allocation-1.png" width="300px" style="display:block;">

## 10- Dynamically Resizing an Array

- 这种可变大小的 array，在 standard library 中使用 vector 已经可以实现。以下内容只是为了介绍，如何使用 pointers，给 array 分配可变内存

```C++
// 直到用户输入一个非number的值，cin中止。之后再打印所有输入的值。这只能输入5个，因为array的大小是5
int main() {
  int* numbers = new int[5];
  int entries = 0;

  while (true) {
    cout << "Number: ";
    cin >> numbers[entries];
    if (cin.fail()) break;
    entries++;
  }

  for (int i = 0; i < entries; i++)
    cout << numbers[i] << endl;

  return 0;
}
```

```C++
// 这是一个可以无限延申的array
int main() {
  int capacity = 5;
  int* numbers = new int[capacity];
  int entries = 0;

  while (true) {
    cout << "Number: ";
    cin >> numbers[entries];
    if (cin.fail()) break;
    entries++;
    if (entries == capacity) {
      // create a temp array (twice the size)
      // copy all the elements
      capacity *= 2;
      int* temp = new int[capacity];
      for ( int i = 0; i < entries; i++)
        temp[i] = numbers[i];
      delete[] numbers;
      // have "numbers" pointer point to the new array
      // numbers 只是一个变量名，指向temp所在的地址。这之前需要清理，原本numbers指向的地址中的内容，因为他们已经无效了
      numbers = temp;
    }
  }

  for (int i = 0; i < entries; i++)
    cout << numbers[i] << endl;

  delete[] numbers;

  return 0;
}
```

## 11- Smart Pointers

- 清理 heap 中的指针，很麻烦，不能 delete 两次，所以现在 c++中，我们使用 smart pointer 来做这件事

## 12- Working with Unique Pointers

- a unique pointer is a kind of pointer that owns the piece of memory it points to. so we cannot have two unique pointers pointing to the same memory location

```C++
// new int: 一个 int 的 pointer
unique_ptr<int> x(new int);
cout << x;
// 16进制内存地址

unique_ptr<int> x(new int);
*x = 10;
cout << *x;
// 10

// 以下操作都是不允许的
// x++
// x+1
// 不可以在上面进行任何arithmetic operation
```

- simplier way to create a unique pointer

<img decoding="async" src="Pointers-12- Working with Unique Pointers.png" width="500px" style="display:block;">

<img decoding="async" src="Pointers-12- Working with Unique Pointers-2.png" width="500px" style="display:block;">

## 13- Working with Shared Pointers

- 可以利用两个 pointer 指向同一个位置

<img decoding="async" src="Pointers-13- Working with Shared Pointers.png" width="500px" style="display:block;">

# Strings

## 2- C Strings

- char name[5] = ... 以下方法不好，不要用，他是在 string 类之前的写法。必须写\0（Null terminator），否则就是一串 char 而非 string

<img decoding="async" src="Strings-2- C Strings.png" width="500px" style="display:block;">

- 写法二： char name[5] = "Qing"; 这种写法中，末尾的\0 被自动添加上
- string 的长度：strlen(name) ---> 4 not 5
- 连接两个 string. 不把 name 改成 50，代码也可以 work，但是会有潜在风险，将一部分数据存在了一些不应该的位置，might encounter nasty bugs

<img decoding="async" src="Strings-2- C Strings-2.png" width="400px" style="display:block;">

- copy string, lastname 的内容被 copy 给 name 了

<img decoding="async" src="Strings-2- C Strings-3.png" width="400px" style="display:block;">

- 比较两个 string

<img decoding="async" src="Strings-2- C Strings-1.png" width="400px" style="display:block;">

## 3- C++ Strings

- 结果是：mosh

<img decoding="async" src="Strings-3- C++ Strings.png" width="300px" style="display:block;">

- 常用方法：name.lenght()
- 不用 concat，直接相加就可以连接，string 类会自动变化 memory 长度

<img decoding="async" src="Strings-3- C++ Strings-1.png" width="300px" style="display:block;">

- 比较两个 string。还可以使用大于号或者小于号进行比较

<img decoding="async" src="Strings-3- C++ Strings-2.png" width="300px" style="display:block;">

- 常用方法：name.starts_with('m'), 会区分大小写
- 常用方法：name.end_with('m')
- 常用方法：name.empty()
- 常用方法：name.front(), 返回第一个 char
- 常用方法：name.back(), 返回最后一个 char

## 4- Modifying Strings

- google: C++ string reference

```C++
// Qing Ye
string name = "Qing";
name.append(" Ye");
cout << name;

// I am Qing
name.insert(0, "I am ");

// ng
name.erase(0, 2);

name.clear();
name = "";

// QIng
name.replace(0, 2, "QI");
```

## 5- Searching Strings

```C++
// 10
// 从 index 7 开始往后，medani，第一次出现a的index
string name = "Mosh Hamedani";
name.find('a', 7);
cout << name;

// 184467440737095516115: size_t 可以存储的最大值
// 下面的结果是 -1， 但是结果的数据结构是 size_t: unsigned int / unsigned long long，size_t cannot store a negative value in it，所以会存储它的最大值
name.find('A');

// 反向寻找，找到最后一个出现的‘a’的index
name.rfind('a')

// 返回传入string（,.;）中的任何一个，首次出现的index
name.find_first_of(",.;")
```

## 6- Extracting Substrings

```C++
// 改变name，不会影响新copy的string，copy cout依然是 Mosh Hamedani
string name = "Mosh Hamedani";
string copy = name.substr();
name = "";
cout << copy;

// Ham
string name = "Mosh Hamedani";
string copy = name.substr(5, 3);
cout << copy;
```

<img decoding="async" src="Strings-6- Extracting Substrings.png" width="500px" style="display:block;">

## 8- String_Numeric Conversion Functions

```C++
// 19.99
double price = stod("19.99x");
cout << price;

// 19
double price = stod("19.x99");
cout << price;

// error
double price = stod("x19.99");
cout << price;

// 19.900000
string str = to_string(19.9);
cout << str;
```

## 10- Raw Strings

```C++
// raw string 就是括起来的内容，写成什么样字，cout就是什么样子，不需要转义字符
string str = R"("c:\folderA\FolderB\file.txt")"
cout << str;
```

# Structures and Enumerations

## 2- Defining Structures

<img decoding="async" src="Structures and Enumerations-2- Defining Structures.png" width="300px" style="display:block;">
<img decoding="async" src="Structures and Enumerations-2- Defining Structures-1.png" width="300px" style="display:block;">
<img decoding="async" src="Structures and Enumerations-2- Defining Structures-2.png" width="400px" style="display:block;">

## 3- Initializing Structures

<img decoding="async" src="Structures and Enumerations-3- Initializing Structures.png" width="500px" style="display:block;">

## 9- Operator Overloading

- 如果想这个方法内部不能修改 movie.title, 就需要 const Movie& movie
- 如果想这个方法内部不能修改 title, 就需要'{'前的那个 const

<img decoding="async" src="Structures and Enumerations-9- Operator Overloading.png" width="500px" style="display:block;">

<img decoding="async" src="Structures and Enumerations-9- Operator Overloading-1.png" width="500px" style="display:block;">

## 11- Pointers to Structures

- 传递引用 &
- 传递指针 \*

  - 只是内存 16 进制地址

- 1

<img decoding="async" src="Structures and Enumerations-11- Pointers to Structures.png" width="300px" style="display:block;">

- 2

<img decoding="async" src="Structures and Enumerations-11- Pointers to Structures-1.png" width="300px" style="display:block;">

- 3

<img decoding="async" src="Structures and Enumerations-11- Pointers to Structures-2.png" width="300px" style="display:block;">

## 13- Strongly Typed Enumerations

```C++

enum class Action {
  List = 1;
  Add = 2,
  Update = 3
}

if (input == static_cast<int>(Action::list)){
  cout << "List invoices";
}
```

# Streams and Files

## 4- Reading from Streams

- 如果让用户填写两个数字, 用户一次性将两个数字都填入了(中间隔着空格, 结尾用回车). 第二个让用户填写的输入就被跳过了. 因为用户的输入, 其实是保存在 buffer 中的, 系统会直接读取第二个, 就不用用户再自己填了

## 5- Handling Input Errors

- while: 的作用是确保 number，如果输入了 char，会要求再输一遍
- cin.clear: 清除 buffer
- cin.ignore(numeric....): 确保只取一个 number, 即使输入了两个数字，依然只取了第一个
- ignore 有两个参数：ignore the next 10 characters or unitil you find the backslash n, \n
  - stream size
  - 结束 char

<img decoding="async" src="Streams and Files-5- Handling Input Errors.png" width="500px" style="display:block;">

<img decoding="async" src="Streams and Files-5- Handling Input Errors-1.png" width="500px" style="display:block;">

<img decoding="async" src="Streams and Files-5- Handling Input Errors-2.png" width="500px" style="display:block;">

## 6- File Streams

- ifstream: input file stream, read data from file
- ofstream: output file stream, write data to file
- fstream: combine, both

## 9- Writing to Binary Files

- binary files: images, audio files, pdf, etc
- binary files： not readable, for machine, not for human

```C++
// reinterpret_cast: 第一个参数接收 char pointer，但是number是int的，需要类型转换
// sizeof(numbers)：第二个参数接收需要从内存读取的size

int numbers[] = {1000000, 2000000, 3000000};
ofstream file('numbers.dat', ios::binary);
if (file.is_open()){
  file.write(reinterpret_cast<char*>(&numbers), sizeof(numbers));
  file.close();
}
```

- each char taskes 1 bits of memory = 10000000/n + 20000000/n + 30000000/n = 24 个字符 = 24 bits
- each int takes 4 bits of memory = 3 个数字 = 12 bits

## 13- Converting Values to Strings

<img decoding="async" src="Streams and Files-13- Converting Values to Strings.png" width="500px" style="display:block;">

## 14- Parsing Strings

```C++
string str = "10 20";
stringstream stream;
stream.str(str);

int first;
stream >> first;

int second;
stream >> second;

cout << first + second;
```

<img decoding="async" src="Streams and Files-14- Parsing Strings.png" width="500px" style="display:block;">

- Terminator 1
- 1984

<img decoding="async" src="Streams and Files-14- Parsing Strings-1.png" width="500px" style="display:block;">
