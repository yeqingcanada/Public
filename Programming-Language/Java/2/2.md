# Classes

## 0-Basics

- Class（类）:
  类是 Java 中的一个基本构建块。它是创建对象的蓝图或模板。类定义了一组具有相同属性（字段）和行为（方法）的对象。例如，一个 Dog 类可能包括字段如 name 和 age，以及方法如 bark()和 eat()。
- Object（对象）:
  对象是类的实例。使用类的定义，您可以创建任意多个对象。每个对象都有自己的身份，并拥有其类的结构。例如，如果 Dog 是一个类，那么一个特定的 Dog 对象可能是一只名叫"Fido"的狗，它具有特定的年龄和特性。
- Instance（实例）:
  实例是对象的同义词。当你根据类创建一个对象时，你就创建了该类的一个实例。简言之，一个实例就是一个具体化的对象。例如，提到“一个 Dog 类的实例”就是指一个具体的 Dog 对象。
- Field（字段）:
  字段是类中定义的变量。字段表示对象的状态，每个对象都拥有其类定义的字段的自己的副本（除非字段被声明为 static，这种情况下，该字段属于类本身，为所有实例共享）。例如，Dog 类可能有一个 name 字段和一个 age 字段，这些字段存储关于特定狗的信息。
- Constructor（构造器）:
  构造器是一种特殊类型的方法，用来初始化新创建的对象，并给对象的字段赋初值。构造器的名称必须与类名相同，并且它没有返回类型。如果在类中没有显式定义构造器，Java 编译器会为该类提供一个默认的无参数构造器。构造器可以被重载，意味着一个类可以有多个构造器，只要它们的参数列表不同。

## 5-Memory Allocation

- 对于类对象，stack 中存储他的引用，指向 heap 中的物理存储位置
- 同一个对象的不同变量，改变其中一个，另一个的相应属性也会同样变化，因为他们指向 heap 中的同一个类对象

### var

Java 中，var 是一个关键字，用于在局部变量声明中启用所谓的局部变量类型推断。这意味着您不需要明确指定变量的类型，编译器可以根据变量的初始化值推断出类型。使用 var 可以使代码更简洁，尤其是在变量类型名称非常长或复杂时。

- var 只能用于局部变量。您不能使用 var 声明类的字段、方法参数或返回类型。
- 变量必须在声明时初始化，这样编译器才能推断类型。
- 使用 var 并不意味着变量是动态类型或其类型可以更改。一旦设置了类型，它就是固定的。

使用 var 时编译器会根据右侧表达式推断类型，因此它非常适用于那些类型表达式非常长或复杂的情况，可以使代码更为清晰。不过，在某些情况下过度使用可能会使代码难以理解，尤其是当类型不明显时。在这种情况下，明确指定类型可能更有助于代码的可读性。

## 13-Method Overloading

- method overloading: create different implementations of it with different parameters
- 建议当方法的参数复杂的情况之下，再使用方法重载

## 14-Constructor Overloading

- 类内部，call 构造函数，利用关键字 this(参数 1，参数 2)

## 15-Static Members

- 类内部，有两种成员：instance members, static memebers
- public static void main()：static 的原因是，enable java runtime to directly call this method without having to create a new object

# Inheritance

## 3-The Object Class

- object.hashCode():
  - integer calculated based on the address of this object in memory, the address of this object goes throug a function called hash function, and the obj of this function is to get a value, and map it to a numeric value which we call hash
- object.toString():
  - the package it originally is from, followed by an @ sign and finnally the hash code, represented as hexadecimal
  - hashcode of this object represented in hexadecimal 十六进制
  - hexadecimal: numbering system that goes beyond our decimal numbering system. in the decimal system we have the digitals 0-8, but in hexadecimal we also have the characters A-F

## 4-Constructor and Inheritance

- 子类如果没有构造函数，会只执行父类的构造函数
- 子类如果有自己的构造函数
  - 首先执行父类的构造函数
  - 然后执行子类的构造函数
  - 子类会自动的执行相同参数列表的父类的构造函数
- 如果参数列表不同，子类需要在自己的构造函数中，先执行： super(传入父类的参数列表)，否则会编译无法通过

## 5-Access Modifiers

- 私有属性和私有方法，都不会被子类看到
- protected：在同一个 package 中，这是 public 的。这个修饰符会让维护变复杂，尽量少用。它对于子类，即使不在同一个 package 中，也是 public 的。
- 如果不添加任何修饰符（public/private/protected），默认值是 package private，在 package 内部是 public 的，在 package 外部是 private 的。这种也要尽量少用

## 6-Overriding Methods

- 我们从父类继承了一个方法，但是需要修改，这就是方法重写
- @ 提示符 annotation：a label that we attach to a class member, 有了这个，我们可以给 java 编译器传递额外信息。使用这些信息，编译器会去 check 相同名字的方法，比如，如果发现参数列表或者返回值不同，会编译不通过

## 7-Upcasting and Downcasting

<img decoding="async" src="Inheritance-7-Upcasting and Downcasting.png" width="400px" style="display:block;">

## 8- Comparing Objects

<img decoding="async" src="Inheritance-8- Comparing Objects.png" width="300px" style="display:block;">

<img decoding="async" src="Inheritance-8- Comparing Objects-2.png" width="200px" style="display:block;">

## 9- Polymorphism

- 如果父类没有默认的构造函数，有带参数的构造函数（有参数就不是默认的），so after you want to extend this class we'll have to call the base constructor using the super key word.

<img decoding="async" src="Inheritance-9- Polymorphism-0.png" width="300px" style="display:block;">

<img decoding="async" src="Inheritance-9- Polymorphism.png" width="300px" style="display:block;">

<img decoding="async" src="Inheritance-9- Polymorphism-1.png" width="300px" style="display:block;">

## 10- Abstract Classes and Methods

- 如果一个类是 abstract 的，他不可以被实例化
- 如果一个父类的方法是 abstract 的，他的子类必须 override 这个方法
- 如果父类的 abstract 的方法没有被子类 override，子类又不想有编译错误。子类也必须是 abstract 的

## 11- Final Classes and Methods

- final class
  - 如果一个类是 final 的，他不可以被子类继承
  - 不要过多使用 final class
  - 如果 we have made so many assumptions 假设 in that implementation, expecially about changing the state, 这种情况下，我们将类定义成 final 的，避免他被 extend
  - 一个具体的例子就是 string，String 这个类是 final 的。why，因为 strings 在 java 中是 immutable 的。我们一旦初始化一个 string 后，我们不能改变其中的内容。任何 string 的方法，都不应该改写 string 的内容，为了确保这个，string 类是 final 的，不可以被继承和改写
- final method
  - 如果一个方法是 final 的，这个方法不可以被 override。we have made certain assumptions, they're changing the state of the class in a particular way, we don't want the subclass to accidentally change this behavior or wreck our assumptions

## 12- Deep Inheritance Hierarchies

- 不要搞多层次继承
- 最多两层，不要搞三层，肯定错

## 13- Multiple Inheritance

- 多继承是指，有多个 parent
- C++和 pytohn 都有多继承，java 没有

# Interfaces

## 3- Tightly-coupled Code

- 如果改变 tax calculator 中的构造函数列表，tax report 中的 new TaxCalculator 就需要修改，否则会编译错误，因为参数不同了

<img decoding="async" src="Interfaces-3- Tightly-coupled Code.png" width="400px" style="display:block;">

-

<img decoding="async" src="Interfaces-3- Tightly-coupled Code-2.png" width="400px" style="display:block;">

## 4- Creating an Interface

- in interface, we don't have any fields, we only have method declarations that determine what needs to be done
- interface 中，方法可以不写 public 关键字，因为他们一定会被 implement by a class, 一定是 public 的
- interface 不可以被实例化
- 当一个类在 implement 一个接口的时候，他也可以同时 extend 他自己的 base class。一个类可以继承一个父类，也可以同时实现多个接口
- our interface said every class that implements me, should have a public method with the exact same signature
- 类中 override 的 method，最好添加 override 装饰器

## 6- Constructor Injection

<img decoding="async" src="Interfaces-5- Dependency Injection.png" width="400px" style="display:block;">

- Main.java

<img decoding="async" src="Interfaces-5- Dependency Injection-1.png" width="400px" style="display:block;">

## 7- Setter Injection

- 如果这就是你需要的，就是用它，否则 constructor injection 会是更常用的

<img decoding="async" src="Interfaces-7- Setter Injection.png" width="300px" style="display:block;">

- Main.java

<img decoding="async" src="Interfaces-7- Setter Injection-1.png" width="400px" style="display:block;">

## 8- Method Injection

<img decoding="async" src="Interfaces-8- Method Injection.png" width="300px" style="display:block;">

<img decoding="async" src="Interfaces-8- Method Injection-1.png" width="300px" style="display:block;">

## 9- Interface Segregation 分离 Principle

- 接口尽量小，包含尽量少的方法。
- 如果想要多个方法，可以利用接口间的 extend，组合成一个大接口

## 12- Fields，Static Methods，Private Methods

java 9 不好的引入：Fields，Static Methods，Private Methods

## 15- Interfaces and Abstract Classes

<img decoding="async" src="Interfaces-15- Interfaces and Abstract Classes.png" width="400px" style="display:block;">

接口（Interface）和抽象类（Abstract Class）是面向对象编程中常用的两种抽象概念，它们在某些方面有相似之处，但在其他方面又有显著的区别。

**接口（Interface）**：

1. 接口只能包含抽象方法和常量的定义，不能包含具体的方法实现或成员变量。
2. 类可以实现多个接口。
3. 接口中的方法默认是公共的，不需要显式声明为公共（public）。
4. 接口用于定义类的行为规范，但不提供任何实现细节。
5. 接口可以被用来实现多态性。

**抽象类（Abstract Class）**：

1. 抽象类可以包含抽象方法和具体方法的定义，还可以包含成员变量。
2. 类只能继承一个抽象类，因为 Java 中不支持多继承。
3. 抽象类中的方法可以是抽象的也可以是具体的。
4. 抽象类可以提供一部分通用的实现细节，子类可以选择性地覆盖这些方法。
5. 抽象类通常用于定义具有共同特征和行为的类的模板。

**区别**：

1. 实现方式：接口只包含方法签名的定义，而抽象类可以包含方法的定义和实现。
2. 多继承：类可以实现多个接口，但只能继承一个抽象类。
3. 成员变量：接口中只能包含常量，而抽象类可以包含成员变量。
4. 设计目的：接口用于定义行为规范，抽象类用于定义类的模板，并提供一部分实现细节。

在实际应用中，应根据具体情况选择使用接口还是抽象类。如果需要定义一组相关但不具体的行为规范，通常会选择接口；如果需要提供一部分通用的实现细节，并且希望子类可以选择性地覆盖这些方法，通常会选择抽象类。
