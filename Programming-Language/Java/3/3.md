# Table of contents

- [Table of contents](#table-of-contents)
- [Exceptions](#exceptions)
  - [3- Types of Exceptions](#3--types-of-exceptions)
  - [4- Exceptions Hierarchy](#4--exceptions-hierarchy)
  - [6- Catching Multiple Types of Exceptions](#6--catching-multiple-types-of-exceptions)
  - [8- The try-with-resources Statement](#8--the-try-with-resources-statement)
  - [9- Throwing Exceptions](#9--throwing-exceptions)
  - [11- Custom Exceptions](#11--custom-exceptions)
  - [12- Chaining Exceptions](#12--chaining-exceptions)
- [Generics](#generics)
  - [4- Generic Classes](#4--generic-classes)
  - [6- Constraints](#6--constraints)
  - [8- Comparable Interface](#8--comparable-interface)
  - [9- Generic Methods](#9--generic-methods)
  - [10- Multiple Type Parameters](#10--multiple-type-parameters)
  - [11- Generic Classes and Inheritance](#11--generic-classes-and-inheritance)
  - [12- Wildcards](#12--wildcards)
- [Collections](#collections)
  - [2- Overview of Collections Framework](#2--overview-of-collections-framework)
  - [3- The Need for Iterables](#3--the-need-for-iterables)
  - [4- The Iterable Interface](#4--the-iterable-interface)
  - [5- The Iterator Interface](#5--the-iterator-interface)
  - [6- The Collection Interface](#6--the-collection-interface)
  - [7- The List Interface](#7--the-list-interface)
  - [8- The Comparable Interface](#8--the-comparable-interface)
  - [9- The Comparator Interface](#9--the-comparator-interface)
  - [10- The Queue Interface](#10--the-queue-interface)
  - [11- The Set Interface](#11--the-set-interface)
  - [12- Hash Tables](#12--hash-tables)
  - [13- The Map Interface](#13--the-map-interface)
- [Lambda Expressions and Functional Interfaces](#lambda-expressions-and-functional-interfaces)
  - [2- Functional Interfaces](#2--functional-interfaces)
  - [3- Anonymous Inner Classes](#3--anonymous-inner-classes)
  - [4- Lambda Expressions](#4--lambda-expressions)
  - [5- Variable Capture](#5--variable-capture)
  - [6- Method References](#6--method-references)
  - [7- Built-in Functional Interfaces](#7--built-in-functional-interfaces)
  - [8- The Consumer Interface](#8--the-consumer-interface)
  - [9- Chaining Consumer](#9--chaining-consumer)
  - [10- The Supplier Interface](#10--the-supplier-interface)
  - [11- The Function Interface](#11--the-function-interface)
  - [12- Composing Functions](#12--composing-functions)
  - [13- The Predicate Interface](#13--the-predicate-interface)
  - [14- Combining Predicates](#14--combining-predicates)
  - [15- The BinaryOperator Interface](#15--the-binaryoperator-interface)
  - [16- The UnaryOperator Interface 一元](#16--the-unaryoperator-interface-一元)
- [Streams](#streams)
  - [2- Imperative vs Functional Programming](#2--imperative-vs-functional-programming)
  - [3- Creating a Stream](#3--creating-a-stream)
  - [4- Mapping Elements](#4--mapping-elements)
  - [5- Filtering Elements](#5--filtering-elements)
  - [6- Slicing Streams](#6--slicing-streams)
  - [7- Sorting Streams](#7--sorting-streams)
  - [8- Getting Unique Elements](#8--getting-unique-elements)
  - [9- Peeking Elements](#9--peeking-elements)
  - [10- Simple Reducers（accumulator）](#10--simple-reducersaccumulator)
  - [11- Reducing a Stream](#11--reducing-a-stream)
  - [12- Collectors](#12--collectors)
  - [13- Grouping Elements](#13--grouping-elements)
  - [14- Partitioning Elements](#14--partitioning-elements)
  - [15- Primitive Type Streams](#15--primitive-type-streams)
- [Concurrency and Multi-threading](#concurrency-and-multi-threading)
  - [2- Processes and Threads](#2--processes-and-threads)
  - [3- Starting a Thread](#3--starting-a-thread)
  - [5- Joining a Thread](#5--joining-a-thread)
  - [6- Interrupting a Thread](#6--interrupting-a-thread)
  - [7- Concurrency Issues](#7--concurrency-issues)
  - [8- Race Conditions 竞争条件](#8--race-conditions-竞争条件)
  - [9- Strategies for Thread Safety](#9--strategies-for-thread-safety)
  - [10- Confinement](#10--confinement)
  - [11- Locks](#11--locks)
  - [12- The synchronized Keyword](#12--the-synchronized-keyword)
  - [13- The volatile Keyword 易挥发的](#13--the-volatile-keyword-易挥发的)
  - [14- Thread Signalling with wait() and notify()](#14--thread-signalling-with-wait-and-notify)
  - [15- Atomic Objects](#15--atomic-objects)
  - [16- Adders](#16--adders)
  - [17- Synchronized Collections](#17--synchronized-collections)
  - [18- Concurrent Collections](#18--concurrent-collections)
- [The Executive Framework](#the-executive-framework)
  - [3- Executors](#3--executors)
  - [4- Callables and Futures](#4--callables-and-futures)
  - [5- Asynchronous Programming](#5--asynchronous-programming)
  - [6- Completable Futures](#6--completable-futures)
  - [7- Creating a Completable Future](#7--creating-a-completable-future)
  - [8- Implementing an Asynchronous API](#8--implementing-an-asynchronous-api)
  - [9- Running Code on Completion](#9--running-code-on-completion)
  - [10- Handling Exceptions](#10--handling-exceptions)
  - [11- Transforming a Completable Future](#11--transforming-a-completable-future)
  - [12- Composing Completable Futures](#12--composing-completable-futures)
  - [13- Combining Completable Futures](#13--combining-completable-futures)
  - [14- Waiting for Many Tasks to Complete](#14--waiting-for-many-tasks-to-complete)
  - [15- Waiting for the First Task](#15--waiting-for-the-first-task)
  - [16- Handling timeouts](#16--handling-timeouts)
  - [17- Project- Best Price Finder](#17--project--best-price-finder)
  - [18- Solution- Getting a Quote](#18--solution--getting-a-quote)
  - [19- Solution- Getting Many Quotes](#19--solution--getting-many-quotes)
  - [20- Solution- Random Delays](#20--solution--random-delays)

# Exceptions

## 3- Types of Exceptions

- checked: compile exceptions, checked at compile time
- unchecked: runtime exceptions
  - NullPointerException: 试图访问 null 的属性
  - ArithmeticException: 处以 0
  - IllegalArgumentException
  - IndexOutOfBoundsException
  - IllegalStateException: we try to call a method, but the underlying object is not in the right state
- error: an error external to our application
  - stack over flow error
  - out of memory error

## 4- Exceptions Hierarchy

- Throwable: every kind of exception or error has an error message and a stack trace 堆栈跟踪

<img decoding="async" src="Exceptions-4- Exceptions Hierarchy-1.png" width="300px" style="display:block;">

<img decoding="async" src="Exceptions-4- Exceptions Hierarchy-2.png" width="400px" style="display:block;">

## 6- Catching Multiple Types of Exceptions

- 如果 Exception1 和 Exception2 需要不同的处理逻辑，应使用第一种方式分别捕获和处理它们。

<img decoding="async" src="Exceptions-6- Catching Multiple Types of Exceptions-2.png" width="400px" style="display:block;">

- 第二种方式则简化了代码，但仅在处理逻辑一致的情况下适用。

<img decoding="async" src="Exceptions-6- Catching Multiple Types of Exceptions-3.png" width="400px" style="display:block;">

## 8- The try-with-resources Statement

- try with resource: close automatically

<img decoding="async" src="Exceptions-8- The try-with-resources Statement.png" width="400px" style="display:block;">

## 9- Throwing Exceptions

- unchecked exception(IllegalArgumentException)，运行时异常
- checked exception(IOException)，编译异常
- 下图中最后一行的 throw new IOException() 直接写会有编译错误，Java compiler is saying we haven't handled this exception, 解决方法：
- 步骤一：就需要像以下这样写，标明这个方法会有可能抛出 IOException (deposit throws IOException)

<img decoding="async" src="Exceptions-9- Throwing Exceptions.png" width="500px" style="display:block;">

- 步骤二： 并且在使用这个 api 的使用利用 try catch 包裹被调用的 deposite

<img decoding="async" src="Exceptions-9- Throwing Exceptions-2.png" width="300px" style="display:block;">

## 11- Custom Exceptions

- checked 继承于 -> Exception
- unchecked(runtime) 继承于 -> RuntimeException

## 12- Chaining Exceptions

- exception 类包含
  - e.initCause()
  - e.getCauase(): returns a throwable

<img decoding="async" src="Exceptions-12- Chaining Exceptions-0.png" width="400px" style="display:block;">

<img decoding="async" src="Exceptions-12- Chaining Exceptions.png" width="600px" style="display:block;">

- terminal 显示： Insufficient funds in your account

<img decoding="async" src="Exceptions-12- Chaining Exceptions-1.png" width="400px" style="display:block;">

# Generics

## 4- Generic Classes

<img decoding="async" src="Generics-4- Generic Classes.png" width="400px" style="display:block;">

<img decoding="async" src="Generics-4- Generic Classes-1.png" width="500px" style="display:block;">

## 6- Constraints

- class GenericList<T extends Comparable & Cloneable>

## 8- Comparable Interface

<img decoding="async" src="Generics-8- Comparable Interface-0.png" width="500px" style="display:block;">

<img decoding="async" src="Generics-8- Comparable Interface.png" width="500px" style="display:block;">

## 9- Generic Methods

```Java
public class Utils {
  public static <T extends Comparable<T>> T max(T first, T second) {
    return (first.compareTo(second) < 0) ? second : first;
  }
}
```

## 10- Multiple Type Parameters

<img decoding="async" src="Generics-10- Multiple Type Parameters.png" width="500px" style="display:block;">

## 11- Generic Classes and Inheritance

- 如果是下图这样，print 一个 user，可以传入 instructor

<img decoding="async" src="Generics-11- Generic Classes and Inheritance.png" width="500px" style="display:block;">

- 但是如果是下图这样，一个 GenericList，打印一个 list，就不对了。因为 java 编译的时候，会给 GenericList 固定类型
- generic list of instructor is not a subtype of generic list of user
- 我们讲过，generic class 是如何工作的。
- this generic list internally maintains s list of objects, no matter what we pass here(here 指的是下图中被选中的部分)。 we only have a single generic list in our project. and this class is not subtype of itself. the reason why is generic list of instructor is not a subtype of generic list of user because we're dealing with a single class

<img decoding="async" src="Generics-11- Generic Classes and Inheritance-1.png" width="500px" style="display:block;">

## 12- Wildcards

```java
public class Main {
  public static void main(String[] arge) {
    var instructors = new GenericList<Instructor>();
    // var users = new GenericList<User>();
    Utils.printUsers(instructors)
  }
}
```

- 当使用？的时候，java 编译器会新建一个匿名 type，它会新建一个叫做 CAP#1 的类
- users.get(0)的返回值就是一个类：capture of ?, 可以把它存在 CAP#1 类型的数据中，或者它的 base type 类型的数据中（object type）
- 当 CAP#1 extend from user 后，可以把 users.get(0)保存成 Users x 但是不可以把它保存成 Instructor x，因为 instructor and cap are two different types

<img decoding="async" src="Generics-12- Wildcards-0.png" width="500px" style="display:block;">

```java
public static void printUsers
  (GenericList<? extends User> users) {
    User x = users.get(0);
    // 下面这行，需要传入 CAP#1 或者它的子类
    // 下面这行是不行的，因为我们不知道 CAP#1 具体是什么类
    users.add(new CAP#1);
}
```

- 使用 super 后，？会被当做 user 类的父类
- super keyword, Java 编译器会 treat this (? super User) unknow type, likt the parent of the user class(Object class)
- users 看作 temp（going to treat users object like temp object）

```java
public static void printUsers
  (GenericList<? super User> users) {
    // 想当于执行了下面一句，来新建这个list
    // GenericList<Object> temp = new GenericList<>();

    // 因为下述两种类都是直接或者间接从 Object 类继承来的，所以可以顺利传入，没有问题
    users.add(new User(1));
    users.add(new Instructor(1));

    // 然而，如果使用super关键字，我们不能从这个list中读取了
    Object x = users.get(0);
    // 下面一行就不对了，它是一个Object，可能是string也可能是date time，所以不能确定是User
    User x = users.get(0);
}
```

- if you want to read from this list, you should use the extends keyword. if you want to add to it you should use the super keyword

# Collections

## 2- Overview of Collections Framework

- Java colletion interfaces
  - list: ordered collection, access by index
  - queque: shared by mulitple consumers

<img decoding="async" src="Collections-2- Overview of Collections Framework.png" width="500px" style="display:block;">

## 3- The Need for Iterables

- 如果想要 for (var item : list)，会有错误，因为 private T[] items = (T[]) new object[10]; 是 private 的
- 可以将它改成 public，但是这样做特别不好。因为外部可以访问 items,public T[] items = (T[]) new object[10] 改成了 public ArrayList<T> items = new ArrayList<>()，下面代码就不对了，因为原本是 T[] 改成了 ArrayList，语法全不一样。
- 所以最好不要将 private 改成 public

```java
public class Main {
  public static void main(String[] args) {
    var list = new GenericList<String>();
    // 改成 array list后，下面这两行就会报错
    // ArrayList doesn't support the square bracket[]
    // ArrayList 没有 length 这个属性
    list.items[0] = "a";
    System.out.println(list.items.lenght);
  }
}
```

## 4- The Iterable Interface

- 正确的改法如下，将 GenericList 继承 Iterable

```java
public class GenericList<T> implements Iterable<T> {
  // 这行代码出现在类的字段声明部分，用于初始化items字段
  // 这行代码不是构造函数的一部分，而是字段声明和初始化的一种方式
  private T[] items = (T[]) new object[10];
  private int count;

  public void add(T item) {
    items[count++] = item;
  }

  public T get(int index) {
    return items[index];
  }

  @Override
  public Iterator<T> iterator() {
    return null;
  }
}

public class Main {
  public static void main(String[] args) {
    var list = new GenericList<String>();
    var iterator = list.iterator();
    while (iterator.hasNext()) {
      var current = iterator.next();
      System.out.println(current);
    }
  }
}

// for loop 的本质与 while hasNext next 一样，只是语法糖
public class Main {
  public static void main(String[] args) {
    var list = new GenericList<String>();
    for (var item : list)
      System.out.println(item);
  }
}
```

## 5- The Iterator Interface

```java
public class GenericList<T> implements Iterable<T> {
  private T[] items = (T[]) new object[10];
  private int count;

  public void add(T item) {
    items[count++] = item;
  }

  public T get(int index) {
    return items[index];
  }

  @Override
  public Iterator<T> iterator() {
    return new ListIterator(this);
  }

  // 如果未来我们想改变private T[] items = (T[]) new object[10]; ---> private ArrayList<T> items = new ArrayList<>()
  // 下面这个部分是唯一需要改变的地方。不会影响外部使用GenericList的其他代码
  private class ListIterator implements Iterator<T> {
    private GenericList<T> list;
    private int index;

    public ListIterator(GenericList<T> list) {
      this.list = list;
    }

    @Override
    public boolean hasNext() {
      return (index < list.count);
    }

    @Override
    public T next() {
      return list.items[index++];
    }
  }
}

public class Main {
  public static void main(String[] args) {
    var list = new GenericList<String>();
    for (var item : list)
      System.out.println(item);
  }
}
```

## 6- The Collection Interface

参考 code in \Code-And-Note\Coding\Programming-Language\Java\3\src\com\codewithmosh\collections\CollectionDemo.java

## 7- The List Interface

- list interface represents an order collection also called a sequence
- we can access objects by index
- collcetion, we don't care about index, we only care about adding or removing them from a collection
- if you want to work with an ordered collection, if you care about the index of objects and a collection, use list interface
- \Code-And-Note\Coding\Programming-Language\Java\3\src\com\codewithmosh\collections\ListDemo.java

## 8- The Comparable Interface

- \Code-And-Note\Coding\Programming-Language\Java\3\src\com\codewithmosh\collections\Customer.java

```java
public class Main {
  public static void main(String[] args) {
    List<Customer> customers = new ArrayList<>();
    customers.add(new Customer("a"));
    customers.add(new Customer("b"));
    customers.add(new Customer("c"));

    // Customer class does not implemnet the comparable interface. 所以下述会报错。我们需要在Customer中实现comparable interface
    Collections.sort(customers);
    System.out.println(customers);
  }
}
```

## 9- The Comparator Interface

- 如果不想只是 sort name，而是像 sort email 怎么办
- \Code-And-Note\Coding\Programming-Language\Java\3\src\com\codewithmosh\collections\Customer.java
- \Code-And-Note\Coding\Programming-Language\Java\3\src\com\codewithmosh\collections\EmailComparator.java

```java
public class Main {
  public static void main(String[] args) {
    List<Customer> customers = new ArrayList<>();
    customers.add(new Customer("a", "e3"));
    customers.add(new Customer("b", "e2"));
    customers.add(new Customer("c", "e1"));
    Collections.sort(customers, new EmailComparator());
    System.out.println(customers);
  }
}
```

## 10- The Queue Interface

- want to process jobs based on the order we recieve them
- ArrrayDeque: deque is short for double ended queue. a queue has two ends
- PriorityQueue: each item gets a priority, and this priority determines the position of this itm in the queue
- \Code-And-Note\Coding\Programming-Language\Java\3\src\com\codewithmosh\collections\QueueDemo.java

## 11- The Set Interface

- contains no duplicates, store a list of unique values

<img decoding="async" src="Collections-11- The Set Interface.png" width="400px" style="display:block;">

```java
// 将一个collection 转换为 set，以便去重
public class SetDemo {
  public static void show() {
    Collection<String> collection = new ArrayList<>();
    Collection.addAll(collection, "a", "b", "c", "c");
    Set<String> set = new HashSet<>(collection);
    // ["a", "b", "c"]
    System.out.println(set);
  }
}
```

- \Code-And-Note\Coding\Programming-Language\Java\3\src\com\codewithmosh\collections\SetDemo.java

## 12- Hash Tables

- 不同于 list/array，hash table 可以 quickly look on an object, no matter how many objects we have stored in the hash table
- Java: Maps
- C#: Dictionary
- Python: Dictionary
- JavaScript: Objects
- var person = { name: "a" }

## 13- The Map Interface

- \Code-And-Note\Coding\Programming-Language\Java\3\src\com\codewithmosh\collections\MapDemo.java
- Map in java is not iterable and is not part of Colleciton

# Lambda Expressions and Functional Interfaces

## 2- Functional Interfaces

- Functional(represent a function) Interface 只有一个 single 抽象 abstract 方法的接口
- 还有一个 java 不太好的引入: Functional Interface 除了一个抽象方法意以外,还可以包含一个 default 方法,其中包含具体的实现步骤
- \Code-And-Note\Coding\Programming-Language\Java\3\src\com\codewithmosh\lambdas\Printer.java
- \Code-And-Note\Coding\Programming-Language\Java\3\src\com\codewithmosh\lambdas\ConsolePrinter.java

<img decoding="async" src="Lambda Expressions and Functional Interfaces-2- Functional Interfaces.png" width="400px" style="display:block;">

## 3- Anonymous Inner Classes

- Anonymous(no name) Inner(inside a method) Classes

<img decoding="async" src="Lambda Expressions and Functional Interfaces-3- Anonymous Inner Classes.png" width="400px" style="display:block;">

## 4- Lambda Expressions

<img decoding="async" src="Lambda Expressions and Functional Interfaces-4- Lambda Expressions.png" width="500px" style="display:block;">

## 5- Variable Capture

- lambda expression can access
  - local variables in the enclosing method(show())
  - static variable(inside LambdsDemo), public static String prefix = "-";
  - instance field(将 show 去掉 static 关键字), 可以 access public String prefix = "-";
- lambda expressions "this" reference to enclosing object(LambdasDemo)
- in anonumous inner class, "this" reference the current instance of the anonymous inner class
- anonumous inner class can have state, they can have fields to store some data

## 6- Method References

```java
// 1
great(message -> System.out.println(message));
great(System.out::println);

// 2
public static void print(String message) {}

public static void show() {
  greet(LambdasDemo::print);
}

// 3
// demo::print 在 Java 中是方法引用，表示对某个类或对象的方法的引用，适用于函数式编程和Lambda表达式。
// demo.print 是直接调用对象的方法，适用于一般的方法调用场景。
public void print(String message) {}

public static void show() {
  var demo = new LambdsDemo();
  greet(demo::print);
}

// 4 传递参数给构造函数
public LambdsDemo(String message) {}

public static void show() {
  greet(message -> new LambdasDemo(message));
  greet(LambdasDemo::new);
}

```

## 7- Built-in Functional Interfaces

- java.util.function: predefined functional interfaces that we can use to preform common tasks
  - consumer: takes single argument and returns no result. void consume(obj)
  - supplier: an operation that takes no input and returns a value so it supplies a value. obj supply()
  - function: represent a function that can map a value to a different value. obj map(obj)
  - predicate: present an operation that takes an object and checks to see if the object satisfies some criteria. bool test(condition). used for filter data

## 8- The Consumer Interface

- 命令式编程
- 声明式编程

<img decoding="async" src="Lambda Expressions and Functional Interfaces-8- The Consumer Interface.png" width="500px" style="display:block;">

## 9- Chaining Consumer

- item.toUpperCase()
- a A a b B b c C c

<img decoding="async" src="Lambda Expressions and Functional Interfaces-9- Chaining Consumer.png" width="500px" style="display:block;">

## 10- The Supplier Interface

<img decoding="async" src="Lambda Expressions and Functional Interfaces-10- The Supplier Interface.png" width="500px" style="display:block;">

## 11- The Function Interface

- BiFunction<T,U,R>
  - T - the type of the first argument to the function
  - U - the type of the second argument to the function
  - R - tye type of the result of the function
- IntFunction<R>: apply(int value) return R type
  - LongFunction<R>
  - DoubleFunction<R>
- ToIntFunction<T>: applyyAsInt(T value) return int
  - ToLongFunction<T>
  - ToDoubleFunction<T>
- IntToLongFunction: applyAsLong(int value) return long

<img decoding="async" src="Lambda Expressions and Functional Interfaces-11- The Function Interface.png" width="500px" style="display:block;">

## 12- Composing Functions

<img decoding="async" src="Lambda Expressions and Functional Interfaces-12- Composing Functions.png" width="500px" style="display:block;">

## 13- The Predicate Interface

- Predicate: test(T t) return boolean
- BiPredicate<T,U>: test(T t, U u) return boolean
  - T - the type of the first argument to the predicate
  - U - the type of the second argument the predicate
- IntPredicate: takes a premium integer and return s Boolean

<img decoding="async" src="Lambda Expressions and Functional Interfaces-13- The Predicate Interface.png" width="600px" style="display:block;">

## 14- Combining Predicates

<img decoding="async" src="Lambda Expressions and Functional Interfaces-14- Combining Predicates.png" width="600px" style="display:block;">

```java
// or
hasLeftBrace.or(hasRightBrace);
// true / false 反转
hasLeftBrace.negate();
```

## 15- The BinaryOperator Interface

<img decoding="async" src="Lambda Expressions and Functional Interfaces-15- The BinaryOperator Interface.png" width="500px" style="display:block;">

## 16- The UnaryOperator Interface 一元

- \Code-And-Note\Coding\Programming-Language\Java\3\src\com\codewithmosh\lambdas\LambdasDemo.java

# Streams

## 2- Imperative vs Functional Programming

- paradigms
  - imperative programming: we have statements that specify how some thing should be done
  - declarative programming: we express logic in terms of what needs to be done. SQL is an example of declarative language
    - functional: a special type of declarative programming
  - object-oriented
  - event-driven
- streams: to process a collection of data in a declarative way/functional way
- every collection in java has a method called stream. stream is a sequence of objects, it doesn't store, it just get data out of collection
- 通过 stream，我们可以 process a collection of objects in a functional way
- \Code-And-Note\Coding\Programming-Language\Java\3\src\com\codewithmosh\streams\Movie.java
- StreamsDemo.java

```java
public class StreamsDemo {
  public static void show() {
    List<Movie> movies = List.of(
      new Moview("a", 10),
      new Moview("b", 15),
      new Moview("c", 20)
    )
  }
}
```

<img decoding="async" src="Streams-2- Imperative vs Functional Programming.png" width="400px" style="display:block;">

## 3- Creating a Stream

- creating streams
  - from collections
  - from arrays
  - from an arbitrary number of objects
  - infinite/finite streams
- \Code-And-Note\Coding\Programming-Language\Java\3\src\com\codewithmosh\streams\CreatingStreamsDemo.java

## 4- Mapping Elements

- we need to transform the value in a string, to do that we use the map or flat map method
- mapping
  - map()
  - flatMap()
- primitive variation of map method: mapToInt(), mapToDouble(), mapToLong()

```java
public class StreamsDemo {
  public static void show() {
    List<Movie> movies = List.of(
      new Moview("a", 10),
      new Moview("b", 15),
      new Moview("c", 20)
    )

    movies.stream()
          .map(movie -> movie.getTitle())
          .forEach(name -> System.out.println(name));
    movies.stream()
          .mapToInt(movie -> movie.getLikes())
          .forEach(likeNumber -> System.out.println(likeNumber));
  }
}
```

- flatMap()

```java
public class StreamsDemo {
  public static void show() {
    // Stream<List<x>> -> Stream<x>
    // Stream<Set<x>> -> Stream<x>
    // Stream<Array<x>> -> Stream<x>
    var stream = Stream.of(List.of(1,2,3), List.of(4,5,6));
    stream.forEach(list -> System.out.println(list));
    // [1,2,3]
    // [4,5,6]

    stream
        .flatMap(list -> list.stream())
        .forEach(n -> System.out.println(n));
    // 1
    // 2
    // 3
    // 4
    // .....
  }
}
```

## 5- Filtering Elements

- intermediate: 不添加 termianl 方法的情况下，下述方法返回另一个 stream
  - map()
  - filter()
- terminal
  - forEach()

## 6- Slicing Streams

- Slicing streams
  - limit(n) 只取 n 个
  - skip(n) 跳过前 n 个
  - takeWhile(predicate), predicate 传入 movie 返回 true/false
    - 直到遇到不满足这个条件的部分，才停止取值
  - dropWhile(predicate)
    - 直到遇到满足这个条件的部分，才开始取值

## 7- Sorting Streams

- implements Comparable<Movie>
  - @Override
  - compareTo

<img decoding="async" src="Streams-7- Sorting Streams.png" width="500px" style="display:block;">

## 8- Getting Unique Elements

<img decoding="async" src="Streams-8- Getting Unique Elements.png" width="400px" style="display:block;">

## 9- Peeking Elements

<img decoding="async" src="Streams-9- Peeking Elements.png" width="600px" style="display:block;">

<img decoding="async" src="Streams-9- Peeking Elements-1.png" width="100px" style="display:block;">

## 10- Simple Reducers（accumulator）

- 都是 terminal operators

<img decoding="async" src="Streams-10- Simple Reducers.png" width="300px" style="display:block;">

```java
// true: 因为至少有一个 movie 的 likes 比 20 大
var result = movies.stream()
                    .anyMatch(m -> m.getLikes() > 20);

// 取第一个元素
// findAny() 取任何一个元素
var result = movies.stream()
                  .findFirst()
                  .get();
System.out.println(result.getTitle());

var result = movies.stream()
                  .max(Comparator.comparing(Movie::getLikes))
                  .get();
System.out.println(result.getTitle());
```

## 11- Reducing a Stream

```java

// [10, 20, 30]
// [30, 30]
// [60]

// 方法一：
// Optional 类代表一个对象，可能也可能不，have a value. the value is optional
Optional<Integer> sum = movies.stream()
                              .map(m -> m.getLikes())
                              .reduce((a, b) -> a + b);
System.out.println(sum.get());
// 设置默认值
System.out.println(sum.orElse(0));

// 方法二：
Optional<Integer> sum = movies.stream()
                              .map(m -> m.getLikes())
                              .reduce(Integer::sum);
System.out.println(sum.orElse(0));

// 方法三：
Integer sum = movies.stream()
                    .map(m -> m.getLikes())
                    .reduce(0, Integer::sum);
System.out.println(sum);
```

## 12- Collectors

```java
// Collectors.toList(): return an instance of the collector interface that knows how to convert a stream into a list
// "result" type: List<Movie>
var result = movies.stream()
                    .filter(m -> m.getLikes() > 10)
                    .collect(Collectors.toList());

// "result" type: java.util.Set<Movie>
var result = movies.stream()
                    .filter(m -> m.getLikes() > 10)
                    .collect(Collectors.toSet());

// {b=20, c=30}
var result = movies.stream()
                    .filter(m -> m.getLikes() > 10)
                    .collect(Collectors.toMap(Movie::getTitle, Movie::getLike));

// {b=内存地址, c=内存地址}
var result = movies.stream()
                    .filter(m -> m.getLikes() > 10)
                    .collect(Collectors.toMap(Movie::getTitle, m -> m));

// {b=内存地址, c=内存地址}
var result = movies.stream()
                    .filter(m -> m.getLikes() > 10)
                    .collect(Collectors.toMap(Movie::getTitle, Function.identity()));

var result = movies.stream()
                    .filter(m -> m.getLikes() > 10)
                    .collect(Collectors.summingInt(Movie::getLikes));
                    // .collect(Collectors.summingDouble(Movie::getLikes));

// IntSummaryStatistices{count=2, sum=50, min=20, average=25.0000, max=30}
var result = movies.stream()
                    .filter(m -> m.getLikes() > 10)
                    .collect(Collectors.SummarizingInt(Movie::getLikes));

// result is a String object
// b, c
var result = movies.stream()
                    .filter(m -> m.getLikes() > 10)
                    .map(Movie::getTitle)
                    .collect(Collectors.joining(", "));
```

## 13- Grouping Elements

- \Code-And-Note\Coding\Programming-Language\Java\3\src\com\codewithmosh\streams\Genre.java

```java
// java.util.Map<Genre, List<Movie>>
// {ACTION=[内存地址1，内存地址2] ... }
var result = movies.stream()
                    .collect(Collectors.groupingBy(Movie::getGenre));

// java.util.Map<Genre, java.util.Set<Movie>>
var result = movies.stream()
                    .collect(Collectors.groupingBy(Movie::getGenre, Collectors.toSet()));

// {THRILLER=1, ACTION=2}
var result = movies.stream()
                    .collect(Collectors.groupingBy(
                              Movie::getGenre,
                              Collectors.counting()));

// {ACTION=b, c， THRILLER=a}
var result = movies.stream()
                    .collect(Collectors.groupingBy(
                              Movie::getGenre,
                              Collectors.mapping(
                                Movie::getTitle,
                                Collectors.joining(", "))));
```

## 14- Partitioning Elements

```java
// java.util.Map<Boolean, List<Movie>>
var result = movies.stream()
                    .collect(Collectors.partitioningBy(m -> m.getLikes() > 20));

// {false=a, b, true=c}
var result = movies.stream()
                    .collect(Collectors.partitioningBy(
                              m -> m.getLikes() > 20,
                              Collectors.mapping(
                                Movie::getTitle,
                                Collectors.joining(", "))));
```

## 15- Primitive Type Streams

```java
// 1-5
IntStream.rangeClosed(1, 5)
          .forEach(System.out::println);

// 1-4
IntStream.range(1, 5)
          .forEach(System.out::println);
```

# Concurrency and Multi-threading

## 2- Processes and Threads

- 两个 threads：
  - main thread main method
  - background thread run the garbage collector, 会将内容中无用空间释放
- 8 个线程 available，每台电脑不一样
  - 4 core \* 2 threads

<img decoding="async" src="Concurrency and Multi-threading-2- Processes and Threads.png" width="600px" style="display:block;">

## 3- Starting a Thread

```java
// DowloadFileTask.java

package com.codewithmosh.concurrency;

public class DownloadFileTask implements Runnable {
  @Override
  public void run() {
    System.out.println("Downloading a file: " + Thread.currentThread().getName());
  }
}
// ThreadDemo.java
package com.codewithmosh.concurrency;

public class ThreadDemo {
  public static void show() {
    System.out.println(Thread.currentThread().getName());

    Thread thread = new Thread(new DownloadFileTask());
    thread.start();
  }
}

// console result:
// main
// Dowloading a file: Thread-0
```

```java
// DowloadFileTask.java

package com.codewithmosh.concurrency;

public class DownloadFileTask implements Runnable {
  @Override
  public void run() {
    System.out.println("Downloading a file: " + Thread.currentThread().getName());
  }
}
// ThreadDemo.java
package com.codewithmosh.concurrency;

public class ThreadDemo {
  public static void show() {
    System.out.println(Thread.currentThread().getName());

    for (var i = 0; i < 10; i++){
      Thread thread = new Thread(new DownloadFileTask());
      thread.start();
    }
  }
}

// console result:
// main
// Dowloading a file: Thread-8
// Dowloading a file: Thread-6
// Dowloading a file: Thread-5
// Dowloading a file: Thread-0
// Dowloading a file: Thread-9
// ...
```

## 5- Joining a Thread

- 我们在下载了一个文件后，需要另一个方法，扫描这个文件，扫描过程很花时间。我们需要让扫描发生在下载以后
- thread.join() will make the current thread that is the main thread that is executing this code, wait for the completion of this download thread

```java
// DowloadFileTask.java

package com.codewithmosh.concurrency;

public class DownloadFileTask implements Runnable {
  @Override
  public void run() {
    System.out.println("Downloading a file: " + Thread.currentThread().getName());

    try {
      Thread.sleep(5000);
    } catch (InterruptedException e) {
      e.printStackTrace();
    }

    System.out.println("Download complete: " + Thread.currentThread().getName());
  }
}

// ThreadDemo.java
package com.codewithmosh.concurrency;

public class ThreadDemo {
  public static void show() {
    Thread thread = new Thread(new DownloadFileTask());
    thread.start();

    try {
      thread.join();
    } catch (InterruptedException e) {
      e.printStackTrace();
    }

    System.out.println("File is ready to be scanned.");
  }
}

// console result:
// Dowloading a file: Thread-0
// 等待 5 秒后
// Download complete: Thread-0
// File is ready to be scanned.
```

- thread.join(); 让 main 停下来，等待这个线程结束
  - 假设 main 是管理 用户 UI 的程序，pause 的时候，用户就不能进行任何操作，会没有反应

## 6- Interrupting a Thread

```java
// DowloadFileTask.java

package com.codewithmosh.concurrency;

public class DownloadFileTask implements Runnable {
  @Override
  public void run() {
    System.out.println("Downloading a file: " + Thread.currentThread().getName());

    for (var i = 0; i < Integer.NAX_VALUE; i++) {
      if (Thread.currentThread().isInterrupted()) return;
      System.out.println("Downloading byte " + i);
    }

    System.out.println("Download complete: " + Thread.currentThread().getName());
  }
}

// ThreadDemo.java
package com.codewithmosh.concurrency;

public class ThreadDemo {
  public static void show() {
    Thread thread = new Thread(new DownloadFileTask());
    thread.start();

    try {
      Thread.sleep(1000);
    } catch (InterruptedException e) {
      e.printStackTrace();
    }

    thread.interrupt();
  }
}

// console result:
// Dowloading a file: Thread-0
// 等待 1 秒期间，不断打印 Downloading byte 2259186 259187 ...
```

- 如果不添加 if (Thread.currentThread().isInterrupted()) return;这个，线程不会停下来。
- thread.interrupt(); 只是给出一个打断信号，需要上面那句才能真正停下来
- 如果一个线程在 sleep，我们发送了一个 interrupt request，sleep 抛出一个异常。这是为什么要用 try catch 将 sleep 包裹

## 7- Concurrency Issues

- if multiple threads access the same data, and at least one of them tries to change it, we are going to have some problems(Concurrency Issues)

## 8- Race Conditions 竞争条件

- DownloadFileTask 参考 DownloadFileTask.java code
- DownloadStatus 如图:

<img decoding="async" src="Concurrency and Multi-threading-8- Race Conditions-1.png" width="400px" style="display:block;">

- ThreadDemo

```java
package com.codewithmosh.concurrency;

public class ThreadDemo {
  public static void show() {
    var status = new DownloadStatus();

    List<Thread> threads = new ArrayList<>();

    for (var i = 0; i < 10; i++){
      var thread = new Thread(new DownloadFileTask(status));
      thread.start();
      threads.add(thread);
    }

    for (var thread: threads) {
      try {
        thread.join();
      } catch (InterruptedException e) {
      e.printStackTrace();
      }
    }

    System.out.println(status.getTotalBytes());
  }
}
```

- totalBytes++
  - the value of totalBytes has to be read from the main memory and stored into CPU
  - CPU is going to increment this value
  - then updated value is going to be stored in the memory
  - none atomic operation: 可以被分解成多个步骤的操作
  - 如果两个线程同时对 totalBytes 增加 1，totalBytes 只会增加 1，不会增加 2

## 9- Strategies for Thread Safety

- confinement 禁闭: 让各个线程之间不共享数据，全部结束后再汇总结果
- immutability：不可更改
- synchronization：不允许多个线程并发的访问同一个 object。使用 lock 来完成这个
- atomic objects: 不将步骤分解，让操作原子化
- partitioning：将数据分成小份，每一份都可以并发访问。
  - java 提供了多种 collection class 利用 partitioning 支持并发. multiple threads can access a collection object, but only one thread at a time can access a segment in that collection

## 10- Confinement

```java
//  ThreadDemo
public class ThreadDemo {
  public static void show() {
    List<Thread> threads = new ArrayList<>();
    List<DownloadFileTask> tasks = new ArrayList<>();

    for (var i = 0; i < 10; i++){
      var task = new DownloadFileTask();
      tasks.add(task);

      var thread = new Thread(task);
      thread.start();
      threads.add(thread);
    }

    for (var thread: threads) {
      try {
        thread.join();
      } catch (InterruptedException e) {
      e.printStackTrace();
      }
    }

    var totalBytes = tasks.stream()
                    .map(t -> t.getStatus().getTotalBytes())
                    .reduce(Integer::sum);

    System.out.println(totalBytes);
  }
}
// DownloadFileTask
public class DownloadFileTask implements Runnable {
  private DownloadStatus status;

  public DownloadFileTask() {
    this.status = new DownloadStatus();
  }

  @Override
  public void run() {
    for (var i = 0; i < Integer.NAX_VALUE; i++) {
      if (Thread.currentThread().isInterrupted()) return;
      System.out.println("Downloading byte " + i);
    }

    System.out.println("Download complete: " + Thread.currentThread().getName());
  }

  public DownloadStatus getStatus() {
    return status;
  }
}
```

## 11- Locks

```java
public class DownloadStatus {
  private int totalBytes;
  private Lock lock = new ReentrantLock();

  public int getTotalBytes() {
    return totalBytes;
  }

  public void incrementTotalBytes() {
    lock.lock();
    try{
      totalBytes++;
    }
    finally {
      lock.unlock();
    }
  }
}
```

## 12- The synchronized Keyword

- 不要使用 this 作为 monitor（下面 code 中的 monitor 是 totalBytesLock）
- 因为，假设有另一个 field，totalFiles，与 totalBytes 基本相似，也使用 this 作为 synchronized 的 monitor
- only one thread at a time can call into a synchronous method of this object
- 如果一个线程在 update totalBytes，其他线程就不能 update totalFiles
- 这会造成开销 cause overhead
- the whole point of synchronization is to make sure that two threads cannot modify the same data at the same time
- 但是我们处理两个 fields，他们使用同一个 monitor，会减小这个类的吞吐量。这会造成不必要的损失

```java
public class DownloadStatus {
  private int totalBytes;
  private Object totalBytesLock = new Object();

  public int getTotalBytes() {
    return totalBytes;
  }

  public void incrementTotalBytes() {
    synchronized (totalBytesLock) {
      totalBytes++;
    }
  }
}
```

## 13- The volatile Keyword 易挥发的

- volatile 解决 visibility 问题，而非 race condition。所以它并不解决，两个线程同步修改数据。但是它可以保证，一个线程修改了数据，其他线程可以看到这个改变
- 如果没添加 volatile。第二个线程会一直等待，因为它没看到 isDone 变化，这是 visibility。一个线程改变了数据，另一个线程看不到改变。因为 java 虚拟机会优化，让代码更快，其中一个优化就是缓存 value。两个线程会分变存储缓存，从缓存中 load 数据，这样更快。一个线程更新了，另一个线程看不到变化。volatile 意味着，不稳定，线程需要从内存中，而不是缓存中读取数据
  - Downloading a file: Thread-0
  - Download complete: Thread-0
- private boolean isDone;
  - Downloading a file: Thread-0
  - 1000000
  - Download complete: Thread-0
- 除了添加 volatile，还有一个办法是给 isDone() 和 done() 添加 synchronized 关键字，但是这个方法不好，会添加开销，因为 while (!status.isDone())会多次 call isDone()

```java
//  ThreadDemo
public class ThreadDemo {
  public static void show() {
    var status = new DownloadStatus();
    var thread1 = new Thread(new DownloadFileTask(status));
    var thread2 = new Thread(() -> {
      while (!status.isDone()) {}
      System.out.println(status.getTotalBytes());
    });

    thread1.start();
    thread2.start();
  }
}
// DownloadFileTask
public class DownloadFileTask implements Runnable {
  private DownloadStatus status;

  public DownloadFileTask() {
    this.status = new DownloadStatus();
  }

  @Override
  public void run() {
    for (var i = 0; i < 1_000_000; i++) {
      if (Thread.currentThread().isInterrupted()) return;
      status.incrementTotalBytes();
    }

    status.done();

    System.out.println("Download complete: " + Thread.currentThread().getName());
  }

  public DownloadStatus getStatus() {
    return status;
  }
}
// DownloadStatus
public class DownloadStatus {
  private boolean isDone;
  private int totalBytes;
  private int totalFiles;
  private Object totalBytesLock = new Object();

  public int getTotalBytes() {
    return totalBytes;
  }

  public void incrementTotalBytes() {
    synchronized (totalBytesLock) {
      totalBytes++;
    }
  }

  ......

  public boolean isDone() {
    return isDone;
  }

  public void done() {
    isDone = true;
  }
}
```

## 14- Thread Signalling with wait() and notify()

- wait() and notify() 很容易造成混乱，尽量少用

<img decoding="async" src="Concurrency and Multi-threading-14- Thread Signalling with wait() and notify()-1.png" width="500px" style="display:block;">

<img decoding="async" src="Concurrency and Multi-threading-14- Thread Signalling with wait() and notify()-2.png" width="500px" style="display:block;">

## 15- Atomic Objects

```java
private AtomicInteger totalBytes = new AtmociInteger();

public int getTotalBytes() {
  return totalBytes.get();
}

public void incrementTotalBytes() {
  totalBytes.incrementAndGet();
}
```

## 16- Adders

- 参考代码 DownloadStatus.java

## 17- Synchronized Collections

- 如果没添加 Collection.synchronizedCollection, 只写 new ArrayList<>()
  - 4，5，6
  - 因为我们这里有一个 race condition，两个线程在并发的 racing 或者说竞争，修改我们的 collection
- 添加后
  - 4,5,6,1,2,3

<img decoding="async" src="Concurrency and Multi-threading-17- Synchronized Collections-1.png" width="500px" style="display:block;">

<img decoding="async" src="Concurrency and Multi-threading-17- Synchronized Collections-2.png" width="300px" style="display:block;">

## 18- Concurrent Collections

- Synchronized Collections 原理是：整个 collecton 被锁住，其他线程等待。但是对于 performance 以及 scalability，随着线程和同步操作的数量增加，会造成负面影响
- Concurrent Collections 原理：将 collection 分段，每个线程只能修改其中其部分

# The Executive Framework

Executor Framework 提供了一套强大的 API，使得 Java 程序可以更方便地创建、管理和控制并发任务。通过使用 Executor、ExecutorService、ScheduledExecutorService 等接口和实现类，可以实现高效的线程池管理和异步编程，从而提升应用程序的性能和响应能力。

## 3- Executors

- pool-1-thread-2
- pool-1-thread-1
- pool-1-thread-2
- pool-1-thread-2
- pool-1-thread-2
- ...... 共 10 个

<img decoding="async" src="The Executive Framework-3- Executors-1.png" width="500px" style="display:block;">

## 4- Callables and Futures

- ExecutorsDemo & LongTask code
- 结果是：
  - Do more work
  - 1

## 5- Asynchronous Programming

- 我们让当前的线程 var result = future.get(); 等待 future = executor.submit 这个线程，这是不对的，我们在浪费线程
- 我们应该写 non-blocking 的代码，俗称 Asynchronous 异步编程

## 6- Completable Futures

## 7- Creating a Completable Future

<img decoding="async" src="The Executive Framework-7- Creating a Completable Future.png" width="500px" style="display:block;">

## 8- Implementing an Asynchronous API

- 参考代码 MailService.java + Main.java
- Main.java:

<img decoding="async" src="The Executive Framework-8- Implementing an Asynchronous API.png" width="400px" style="display:block;">

- consule 结果
  - Hello World
  - 等待 5 秒
  - Mail was sent.

## 9- Running Code on Completion

- thenRun ---> main
- thenRunAsync ---> ForkJoinPool.commonPool-worker-3

<img decoding="async" src="The Executive Framework-9- Running Code on Completion-1.png" width="500px" style="display:block;">

- thenAccept: get the result of this completable future
  - 接收 consumer object
  - consumer interface 只有一个 accept 方法，接收 object，返回 void
- 下图结果
  - main
  - 1

<img decoding="async" src="The Executive Framework-9- Running Code on Completion-2.png" width="500px" style="display:block;">

## 10- Handling Exceptions

- .exceptionally() 会返回一个新的 completable future 可完成的
- console result
  - Getting the current weather
  - 1
- 没添加.exceptionally(ex->1)之前的结果
  - Getting the current weather
  - ExcutionException

<img decoding="async" src="The Executive Framework-10- Handling Exceptions.png" width="600px" style="display:block;">

## 11- Transforming a Completable Future

- 不必要 call get(), 我们可以 run code upon completion of a task
  - thenRun: excuting a task
  - thenAccept: excuting a task, but also passing the result to that task
- future = CompletableFuture.supplyAsync()
  - we create a completatble future to call our remote API

<img decoding="async" src="The Executive Framework-11- Transforming a Completable Future-1.png" width="600px" style="display:block;">

- 改写成:

<img decoding="async" src="The Executive Framework-11- Transforming a Completable Future-2.png" width="600px" style="display:block;">

## 12- Composing Completable Futures

- 结果是: playlist

<img decoding="async" src="The Executive Framework-12- Composing Completable Futures-1.png" width="600px" style="display:block;">

- 可以改写成:

<img decoding="async" src="The Executive Framework-12- Composing Completable Futures-2.png" width="600px" style="display:block;">

## 13- Combining Completable Futures

- 结果: 18.0

<img decoding="async" src="The Executive Framework-13- Combining Completable Futures-1.png" width="600px" style="display:block;">

- 更复杂:

<img decoding="async" src="The Executive Framework-13- Combining Completable Futures-2.png" width="600px" style="display:block;">

## 14- Waiting for Many Tasks to Complete

- 1
- All tasks completed successfully

<img decoding="async" src="The Executive Framework-14- Waiting for Many Tasks to Complete.png" width="600px" style="display:block;">

## 15- Waiting for the First Task

- 立即就能得到 20,不必等待 3 秒(LongTask 中会等 3 秒)

<img decoding="async" src="The Executive Framework-15- Waiting for the First Task.png" width="600px" style="display:block;">

## 16- Handling timeouts

- 当 call remote service 的时候,我们想要设置一个最长等待 response 时间
- orTimeout

<img decoding="async" src="The Executive Framework-16- Handling timeouts-1.png" width="600px" style="display:block;">

- completionOnTimeout, 三个参数, 第一个是如果超时需要返回的 default value
- 不会报错, 会显示 default value 1

<img decoding="async" src="The Executive Framework-16- Handling timeouts-2.png" width="600px" style="display:block;">

## 17- Project- Best Price Finder

<img decoding="async" src="The Executive Framework-17- Project- Best Price Finder.png" width="400px" style="display:block;">

## 18- Solution- Getting a Quote

- Quote.java
- FlightService:

<img decoding="async" src="The Executive Framework-18- Solution- Getting a Quote-1.png" width="600px" style="display:block;">

- console
  - Getting a quote from site1
  - Quote{site='site1', price=102}

<img decoding="async" src="The Executive Framework-18- Solution- Getting a Quote-2.png" width="500px" style="display:block;">

## 19- Solution- Getting Many Quotes

- Quote.java
- FlightService.java
- CompletableFutureDemo:

<img decoding="async" src="The Executive Framework-19- Solution- Getting Many Quotes.png" width="500px" style="display:block;">

## 20- Solution- Random Delays
