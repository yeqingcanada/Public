# Table of contents

- [Table of contents](#table-of-contents)
- [Binary Trees](#binary-trees)
  - [2- What are Trees](#2--what-are-trees)
  - [4- Exercise- Building a Tree](#4--exercise--building-a-tree)
  - [省略章节](#省略章节)
  - [7- Traversing Trees](#7--traversing-trees)
  - [8- Exercise- Tree Traversal](#8--exercise--tree-traversal)
  - [9- Recursion 递归](#9--recursion-递归)
  - [省略章节](#省略章节-1)
  - [20- Trees- Exercises](#20--trees--exercises)
  - [21- Summary](#21--summary)
- [AVL Trees 自平衡二叉树](#avl-trees-自平衡二叉树)
  - [2- Balanced and Unbalanced Trees](#2--balanced-and-unbalanced-trees)
  - [3- Rotations](#3--rotations)
  - [4- AVL Trees](#4--avl-trees)
  - [5- Exercise: AVL Rotations](#5--exercise-avl-rotations)
  - [省略章节](#省略章节-2)
  - [16- AVL Trees- Exercises](#16--avl-trees--exercises)
  - [17- Summary](#17--summary)
- [Heaps 完全二叉树](#heaps-完全二叉树)
  - [2- What are Heaps](#2--what-are-heaps)
  - [3- Exercise- Working with Heaps](#3--exercise--working-with-heaps)
  - [省略章节](#省略章节-3)
  - [8- Heap Sort](#8--heap-sort)
  - [9- Priority Queues](#9--priority-queues)
  - [10- Exercise- Heapify](#10--exercise--heapify)
  - [省略章节](#省略章节-4)
  - [15- Heaps- Exercises](#15--heaps--exercises)
- [Tries 前缀树或字典树](#tries-前缀树或字典树)
  - [2- What are Tries](#2--what-are-tries)
  - [3- Exercise- Populating a Trie 填充](#3--exercise--populating-a-trie-填充)
  - [省略章节](#省略章节-5)
  - [15- Tries- Exercises](#15--tries--exercises)
- [Graphs](#graphs)
  - [2- What are Graphs](#2--what-are-graphs)
  - [3- Adjacency Matrix](#3--adjacency-matrix)
  - [4- Adjacency List](#4--adjacency-list)
  - [8- Traversal Algorithms](#8--traversal-algorithms)
  - [省略章节](#省略章节-6)
  - [20- Graphs Summary](#20--graphs-summary)
- [Undirected Graphs](#undirected-graphs)
  - [2- Exercise- Weighted Graphs](#2--exercise--weighted-graphs)
  - [3- Solution- Weighted Graphs](#3--solution--weighted-graphs)
  - [5- Dijkstra's Shortest Path Algorithm](#5--dijkstras-shortest-path-algorithm)
    - [关键概念](#关键概念)
    - [算法步骤](#算法步骤)
    - [示例](#示例)
  - [省略章节](#省略章节-7)

# Binary Trees

## 2- What are Trees

- lookup O(log n)
- insert O(log n)
- delete O(log n)

## 4- Exercise- Building a Tree

<img decoding="async" src="Binary Trees-4- Exercise- Building a Tree.png" width="400px" style="display:block;">

## 省略章节

- Tree.java
- 5- Solution- insert()
- 6- Solution- find()

## 7- Traversing Trees

- 广度优先遍历, breadth first traversing

<img decoding="async" src="Binary Trees-7- Traversing Trees-1.png" width="400px" style="display:block;">

- 深度优先遍历, depth first traversing
  - pre-order
  - in-order
  - post-order

<img decoding="async" src="Binary Trees-7- Traversing Trees-2.png" width="400px" style="display:block;">

<img decoding="async" src="Binary Trees-7- Traversing Trees-3.png" width="400px" style="display:block;">

<img decoding="async" src="Binary Trees-7- Traversing Trees-4.png" width="400px" style="display:block;">

<img decoding="async" src="Binary Trees-7- Traversing Trees-5.png" width="400px" style="display:block;">

## 8- Exercise- Tree Traversal

<img decoding="async" src="Binary Trees-8- Exercise- Tree Traversal.png" width="400px" style="display:block;">

<img decoding="async" src="Binary Trees-8- Exercise- Tree Traversal-1.png" width="400px" style="display:block;">

## 9- Recursion 递归

<img decoding="async" src="Binary Trees-9- Recursion-0.png" width="400px" style="display:block;">

<img decoding="async" src="Binary Trees-9- Recursion.png" width="400px" style="display:block;">

## 省略章节

- 10- Depth First Traversals
- 11- Depth and Height of Nodes
- 12- Minimum Value in a Tree
- 13- Exercise- Equality Checking
- 14- Solution- Equality Checking
- 15- Exercise- Validating Binary Search Trees
- 16- Solution- Validating Binary Search Trees
- 17- Exercise- Nodes at K Distance
- 18- Solution- Nodes at K Distance from the Root
- 19- Level Order Traversal

## 20- Trees- Exercises

- solutions
  - Tree.size()
  - Tree.countLeaves()
  - Tree.max()
  - Tree.contains()
  - Tree.areSibling()
  - Tree.getAncestors()

## 21- Summary

- 二叉树中, 一个节点可以有两个子节点
- 没有任何子节点的节点,叫做 leaf
- leaf 的 height 是 0
- 整棵树的 height 是 root 的 height
- root 的 depth 是 0
- 每个节点到达 root 的长度是它本身的 depth
- 二叉搜索树是一种特别的二叉树, 左侧的所有节点都小于 root, 右侧的所有节点都大于 root

# AVL Trees 自平衡二叉树

## 2- Balanced and Unbalanced Trees

<img decoding="async" src="AVL Trees-2- Balanced and Unbalanced Trees.png" width="400px" style="display:block;">

## 3- Rotations

- Left(LL)

<img decoding="async" src="AVL Trees-3- Rotations.png" width="200px" style="display:block;">

<img decoding="async" src="AVL Trees-3- Rotations-1.png" width="200px" style="display:block;">

- Right(RR)

<img decoding="async" src="AVL Trees-3- Rotations-2.png" width="200px" style="display:block;">

<img decoding="async" src="AVL Trees-3- Rotations-3.png" width="200px" style="display:block;">

- Left-Right(LR)

<img decoding="async" src="AVL Trees-3- Rotations-4.png" width="200px" style="display:block;">

<img decoding="async" src="AVL Trees-3- Rotations-5.png" width="200px" style="display:block;">

<img decoding="async" src="AVL Trees-3- Rotations-6.png" width="200px" style="display:block;">

- Right-Left(RL)

<img decoding="async" src="AVL Trees-3- Rotations-7.png" width="200px" style="display:block;">

<img decoding="async" src="AVL Trees-3- Rotations-8.png" width="200px" style="display:block;">

<img decoding="async" src="AVL Trees-3- Rotations-9.png" width="200px" style="display:block;">

## 4- AVL Trees

- 左右 depth 相差 2，就需要 rotate

## 5- Exercise: AVL Rotations

- 参考 Exercises/2-1- AVL Rotations

## 省略章节

- AVLTree.java
- 6- Exercise- Building an AVL Tree
- 7- Solution- insert()
- 8- Exercise- Height Calculation
- 9- Solution- Height Calculation
- 10- Exercise- Balance Factor
- 11- Solution- Balance Factor
- 12- Exercise- Detecting Rotations
- 13- Solution- Detecting Rotations
- 14- Exercise- Implementing Rotations
- 15- Solution- Implementing Rotations

## 16- AVL Trees- Exercises

- solutions
  - Tree.isBalanced()
  - Tree.isPerfect()

## 17- Summary

- balanced tree：the difference between the height of the left and right sub tree of every node should be less than or equal to one
- binary search tree operations running logarithmic time(O(log n)) if the tree is balanced
- unbalanced tree 搜索时间复杂度，最差为 O(n), 与链表相同

# Heaps 完全二叉树

## 2- What are Heaps

- complete tree: 除了最后一层，每层都必须是完全的 node，而且 node 都是从左向右被填入的
- value of every node is greater than or equal with children(heap property)
- max heap
- min heap: the root node holds the smallest value

## 3- Exercise- Working with Heaps

- 参考 Exercises/3-1- Exercise- Working with Heaps

## 省略章节

- 参考代码 Heap.java
- 4- Exercise- Building a Heap
- 5- Solution- insert()
- 6- Solution- remove()
- 7- Solution - Edge Cases

## 8- Heap Sort

<img decoding="async" src="Heaps-8- Heap Sort.png" width="500px" style="display:block;">

## 9- Priority Queues

<img decoding="async" src="Heaps-9- Priority Queues.png" width="500px" style="display:block;">

- 如果使用 heap 实现 priority queue，时间复杂度会下降，如上图
- 参考代码 PriorityQueueWithHeap.java

## 10- Exercise- Heapify

- heapify(array), 将传入的 array，转换成 heap

## 省略章节

- 参考代码 MaxHeap.java
- 11- Solution- Heapify
- 12- Solution- Optimization
- 13- Exercise- Kth Largest Item
- 14- Solution- Kth Largest Item

## 15- Heaps- Exercises

- solutions
  - Heap.isMaxHeap()
  - MinHeap
  - MinPriorityQueue

# Tries 前缀树或字典树

## 2- What are Tries

<img decoding="async" src="Tries-2- What are Tries.png" width="400px" style="display:block;">

## 3- Exercise- Populating a Trie 填充

Build a Trie with the following words.  
boy, book, border, cat, dog, doctor, fine, finest, figure, pick, pickle, picture

[check your answer here](https://www.cs.usfca.edu/~galles/visualization/Trie.html)

## 省略章节

- 4- Exercise- Building a Trie
- 5- Solution- Building a Trie
- 6- An Implementation with a HashTable
- 7- A Better Abstraction
- 8- Exercise- Looking Up a Word
- 9- Solution- Looking Up a Word
- 10- Traversals
- 11- Exercise- Removing a Word
- 12- Solution- Removing a Word
- 13- Exercise- Auto Completion
- 14- Solution- Auto Completion
  - findWords

## 15- Tries- Exercises

- solutions
  - Trie.containsRecursive()
  - Trie.countWords()
  - Trie.longestCommonPrefix()

# Graphs

## 2- What are Graphs

- node: vertex 顶点

## 3- Adjacency Matrix

邻接矩阵：行\*列，每个节点是一个行/列的 index 元素，两个节点交叉为 1 这有边，否则没有连接

<img decoding="async" src="Graphs-3- Adjacency Matrix.png" width="400px" style="display:block;">

- Space: O(n^2)
- Add Node: O(n^2), 因为需要跟换一个内存中的新位置，复制全部 graph 过去
- Remove Node: O(v^2)
- Add Edge: O(1)
  - 我们可以将节点和他们的 index 存在一个 hash table 中
- Remove Edge: O(1)
- Find Neighbors: O(v)

<img decoding="async" src="Graphs-3- Adjacency Matrix-2.png" width="300px" style="display:block;">

## 4- Adjacency List

<img decoding="async" src="Graphs-3- Adjacency List-0.png" width="300px" style="display:block;">

<img decoding="async" src="Graphs-3- Adjacency List.png" width="300px" style="display:block;">

## 8- Traversal Algorithms

## 省略章节

- 5- Exercise- Building a Graph
- 6- Solution- Adding Nodes and Edges
- 7- Solution- Removing Nodes and Edges
- 9- Exercise- Traversal Algorithms
- 10- Exercise- Depth-first Traversal (Recursive)
- 11- Solution- Depth-first Traversal (Recursive)
- 12- Exercise- Depth-first Traversal (Iterative)
- 13- Solution- Depth-first Traversal (Iterative)
- 14- Exercise- Breadth-first Traversal (Iterative)
- 15- Solution- Breadth-first Traversal
- 16- Exercise- Topological Sorting
- 17- Solution- Topological Sort
- 18- Exercise- Cycle Detection (Directed Graphs)
- 19- Solution- Cycle Detection (Directed Graphs)

## 20- Graphs Summary

<img decoding="async" src="Graphs-20- Graphs Summary.png" width="400px" style="display:block;">

# Undirected Graphs

## 2- Exercise- Weighted Graphs

<img decoding="async" src="Undirected Graphs-2- Exercise- Weighted Graphs.png" width="400px" style="display:block;">

## 3- Solution- Weighted Graphs

<img decoding="async" src="Undirected Graphs-3- Solution- Weighted Graphs-1.png" width="700px" style="display:block;">

<img decoding="async" src="Undirected Graphs-3- Solution- Weighted Graphs-2.png" width="400px" style="display:block;">

## 5- Dijkstra's Shortest Path Algorithm

Dijkstra 最短路径算法是一种用于寻找图中节点之间最短路径的著名算法。该算法由计算机科学家艾兹赫·戴克斯特拉于 1956 年构思，并在三年后发表。

### 关键概念

1. **图**：图由节点（顶点）和连接这些节点的边组成。每条边都有一个权重，通常表示节点之间的距离或成本。

2. **源节点**：从图中的起始点开始，计算到所有其他节点的最短路径。

### 算法步骤

1. **初始化**

   - 为图中的每个节点分配一个初始距离：源节点为 0，其他节点为无穷大。
   - 创建一个未处理节点的集合（通常使用优先队列来管理）。

2. **选择节点**

   - 从未处理节点集合中选择距离源节点最近的节点（初始时选择源节点）。

3. **更新邻居节点**

   - 对当前节点的每个邻居节点，计算从源节点到该邻居节点的距离。
   - 如果通过当前节点到达邻居节点的距离比已知最短距离更短，则更新该邻居节点的最短距离。

4. **标记处理完成**

   - 将当前节点标记为已处理，从未处理节点集合中移除。

5. **重复步骤 2-4**
   - 直到所有节点都被处理完或所有未处理节点的最短距离为无穷大（即无法到达）。

### 示例

假设有一个图如下：

```
    A
   / \
 1/   \3
 /     \
B       C
 \2   4/
  \   /
   \ /
    D
```

从节点 A 出发，使用 Dijkstra 算法的步骤如下：

1. 初始化：

   - A: 0（源节点）
   - B: ∞
   - C: ∞
   - D: ∞
   - 未处理节点集合：{A, B, C, D}

2. 选择节点 A（距离最短，为 0）：

   - 更新 B 的距离为 1（0+1）
   - 更新 C 的距离为 3（0+3）
   - 未处理节点集合：{B, C, D}

3. 选择节点 B（距离最短，为 1）：

   - 更新 D 的距离为 3（1+2）
   - 未处理节点集合：{C, D}

4. 选择节点 C（距离最短，为 3）：

   - 通过 C 到 D 的距离为 7（3+4），但已经有更短的距离，所以不更新
   - 未处理节点集合：{D}

5. 选择节点 D（距离最短，为 3）：
   - 已处理完所有节点

最终结果：

- A 到 B 的最短距离为 1
- A 到 C 的最短距离为 3
- A 到 D 的最短距离为 3

通过这些步骤，Dijkstra 算法有效地找到从源节点到其他所有节点的最短路径。

## 省略章节

WeightedGraph.java

- 4- An Object-oriented Solution (提取 Path 为一个 Class)
- 6- Exercise- Getting the Shortest Distance
- 7- Solution- The Shortest Distance
- 8- Solution- Shortest Path
- 9- Exercise- Cycle Detection (Undirected Graphs)
- 10- Solution- Cycle Detection (Undirected Graphs)
- 11- Minimum Spanning Tree
- 12- Exercise- Prim's Algorithm
- 13- Solution- Prim's Algorithm
