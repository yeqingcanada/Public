# Prototype Pattern

## 1-The Problem

- 违反了开闭原则，每次我们想要搞一种新的 shape，我们必须回来修改 duplicate 方法
- 第二个问题是，ContextMenu 与 Circle 的耦合。ContextMenu 需要知道所有 shape，more shape more 耦合

```Java
public interface Component {
  void render();
}


public class Circle implements Component {
  private int radius;

  public int getRadius() {
    return radius;
  }

  public void setRadius(int radius) {
    this.radius = radius;
  }

  @Override
  public void render() {
    System.out.println("Rendering a circle");
  }
}


public class ContextMenu {
  public void duplicate(Component component) {
    Circle source = (Circle)componenet;
    Circle target = new Circle();
    target.setRadius(source.getRadius());
    // Add target to our document
  }
}
```

## 2-Solution

<img decoding="async" src="Prototype Pattern-2-Solution-1.png" width="400px" style="display:block;">

<img decoding="async" src="Prototype Pattern-2-Solution-2.png" width="400px" style="display:block;">

<img decoding="async" src="Prototype Pattern-2-Solution-3.png" width="400px" style="display:block;">

## 4-Exercise

<img decoding="async" src="Prototype Pattern-4-Exercise.png" width="400px" style="display:block;">

# Singleton Pattern

## 1-The Problem

- Singleton Pattern: to ensure a class has a single instance
- main 的结果是 null，因为不应该实例化两个 manager

<img decoding="async" src="Singleton Pattern-1-The Problem-1.png" width="500px" style="display:block;">

<img decoding="async" src="Singleton Pattern-1-The Problem-2.png" width="500px" style="display:block;">

## 2-Solution

<img decoding="async" src="Singleton Pattern-2-Solution-1.png" width="200px" style="display:block;">

<img decoding="async" src="Singleton Pattern-2-Solution-2.png" width="200px" style="display:block;">

## 3-Implementation

main 的结果是 Mosh

<img decoding="async" src="Singleton Pattern-3-Implementation.png" width="500px" style="display:block;">

## 4-Exercise

<img decoding="async" src="Singleton Pattern-4-Exercise.png" width="500px" style="display:block;">

# Factory Method Pattern

## 1-The Problem

- defer the creation of an object to subclass
- 问题是，controller is for MatchaViewEngine,如果用户想要使用别的 engine 怎么办. 给 render 添加第三个参数 ViewEngine engine
- 但是这样一来，in every method of every controller, 我们都需要新建一个 view engine，这是个问题

```Java
public class MatchaViewEngine {
  public String render(String viewName, Map<String, Object> context) {
    return "View rendered by Matcha";
  }
}

public class Controller {
  public void render(String viewName, Map<String, Object> context, ViewEngine engine) {
    // var engine = new MatchaViewEngine();
    var html = engine.render(viewName, context);
    System.out.println(html);
  }
}

public class ProductsController extends Controller {
  public void listProducts() {
    // Get products from a database
    Map<String, Object> context = new HashMap<>();
    // context.put(products)
    render("products.html", context, new MatchaViewEngine());
  }
}
```

## 2-Solution

<img decoding="async" src="Factory Method Pattern-2-Solution-1.png" width="400px" style="display:block;">
<img decoding="async" src="Factory Method Pattern-2-Solution-2.png" width="400px" style="display:block;">

## 3-Implementation

```Java
public class Main {
  public static void main(String[] args) {
    new ProductsController().listProducts();
  }
}
// ProductsController extends Controller
// View rendered by Matcha

// ProductsController extends SharpController
// View rendered by Sharp
```

## 4-Exercise

<img decoding="async" src="Factory Method Pattern-4-Exercise.png" width="400px" style="display:block;">
# Abstract Factory Pattern

# Abstract Factory Pattern

## 1-The Problem

- Abstract Factory Pattern: provide an interface for creating families of related objects
- depending on the currently selected theme, all our widgets should have a consistent look and feel
- so if the currently selected theme is material design, we don't want to show ant button
- so here we have family or related objects
- we have one family on widgets work, material design, and another family for ant

<img decoding="async" src="Abstract Factory Pattern-1-The Problem.png" width="400px" style="display:block;">

## 2-Solution

<img decoding="async" src="Abstract Factory Pattern-2-Solution-1.png" width="400px" style="display:block;">
<img decoding="async" src="Abstract Factory Pattern-2-Solution-2.png" width="400px" style="display:block;">
<img decoding="async" src="Abstract Factory Pattern-2-Solution-3.png" width="400px" style="display:block;">

## 3-Implementation

<img decoding="async" src="Abstract Factory Pattern-3-Implementation-1.png" width="500px" style="display:block;">

<img decoding="async" src="Abstract Factory Pattern-3-Implementation-2.png" width="500px" style="display:block;">

## 4-Exercise

<img decoding="async" src="Abstract Factory Pattern-4-Exercise.png" width="500px" style="display:block;">

# Builder Pattern

## 1-The Problem

- to separate the construction of an object from its representation
- save file into different format pdf/text/image...
- problems:

  - 违反了开闭原则，如果我想 support a new presentation format, we have to come back and modify thie export method
  - tight coupling between the presentation class and these other classes like PDFDocument, Movie。随着我们支持越来越多的 presentation 格式，我们的耦合变多
  - presentation class should also have the knowledge of the structure of these classed。这个方法中，presentation 类需要知道 PDFDocument 包含 addPage 方法. 这个类会需要 maintain so much knowledge which belong to somewhere else
  - 最后一个问题是，关于 export 逻辑的重复。如果添加 copy 逻辑，参考下图

- Slide

<img decoding="async" src="Builder Pattern-1-The Problem-1.png" width="300px" style="display:block;">

- PdfDocument

<img decoding="async" src="Builder Pattern-1-The Problem-2.png" width="400px" style="display:block;">

- Movie

<img decoding="async" src="Builder Pattern-1-The Problem-4.png" width="400px" style="display:block;">

- Presentation

<img decoding="async" src="Builder Pattern-1-The Problem-3.png" width="400px" style="display:block;">

<img decoding="async" src="Builder Pattern-1-The Problem-5.png" width="400px" style="display:block;">

- add copy logic

<img decoding="async" src="Builder Pattern-1-The Problem-6.png" width="400px" style="display:block;">

## 2-Solution

- to separate the construction of an object from its representation
- to separate the exporting logic from the presentation format
- presentation 中的 export 方法的逻辑是 construction 逻辑，一个构建 presentation 的逻辑
- PdfDocumentBuilder 的逻辑是 representation 逻辑，我们如何 representing a presentation

<img decoding="async" src="Builder Pattern-2-Solution-1.png" width="500px" style="display:block;">

<img decoding="async" src="Builder Pattern-2-Solution-2.png" width="400px" style="display:block;">

## 3-Implementation

```Java
public static void main(String[] args) {
    var presentation = new Presentation();
    presentation.addSlide(new Slide("Slide 1"));
    presentation.addSlide(new Slide("Slide 2"));

    var builder = new MoviewBuilder();
    presentation.export(builder);
    var movie = builder.getMovie();
    // Adding a frame to the movie
    // Adding a frame to the movie
    // Adding a frame to the movie

    var builder = new PdfDocumentBuilder();
    presentation.export(builder);
    var pdf = builder.getPdfDocument();
    // Adding a page to PDF
    // Adding a page to PDF
    // Adding a page to PDF
}
```

## 4-Exercise

<img decoding="async" src="Builder Pattern-4-Exercise.png" width="400px" style="display:block;">
