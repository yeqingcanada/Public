# Composite Pattern

## 1-The Problem

- we use this pattern, when we want to represent a hierarchy of objects
- 下面就是一个 hierarchy
- group
  - group1
    - square
    - square
  - group2
    - circle
    - cirel
- 在 group class 中，我们需要 check the type of the object,在 call method 之前将它转换成另一个 type((Shape)object).render(). 如果未来有别的 method，我们也需要重复同样的结构

<img decoding="async" src="Composite Pattern-1-The Problem-1.png" width="340px" style="display:block;">

<img decoding="async" src="Composite Pattern-1-The Problem-2.png" width="400px" style="display:block;">

<img decoding="async" src="Composite Pattern-1-The Problem-3.png" width="400px" style="display:block;">

<img decoding="async" src="Composite Pattern-1-The Problem-4.png" width="200px" style="display:block;">

<img decoding="async" src="Composite Pattern-1-The Problem-5.png" width="150px" style="display:block;">

## 2-Solution

- 在 group 中 render 的时候，不用再判断是什么类型了，因为是 component 类型，component 中就自带 render 方法

<img decoding="async" src="Composite Pattern-2-Solution-1.png" width="300px" style="display:block;">

<img decoding="async" src="Composite Pattern-2-Solution-2.png" width="300px" style="display:block;">

## 3-Implementation

- main 中，最后一行加上 group.move()，console 中显示四行 Render Shape, 四行 Move Shape

## 4-Exercise

<img decoding="async" src="Composite Pattern-4-Exercise.png" width="300px" style="display:block;">

# Adapter Pattern

## 1-The Problem

- we want to build one of these mobile apps for our playing pretty filters to our photos. so we can capture or load a photo, and then apply various fitlers to it
- 问题是，这时候，我使用一个第三方 filter，它没有实现 Filter 接口，imageView.apply(new AnotherFitler()); 这句话会有编译错误

```Java
public class Image {
}

public interface Filter {
  void apply(Image image);
}

public class ImageView {
  private Image image;

  public ImageView(Image image) {
    this.image = image;
  }

  public void apply(Filter filter) {
    filter.apply(image);
  }
}

public class VividFilter implements Filter {
  @Override
  public void apply(Image image) {
    System.out.println("Applying Vivid Filter");
  }
}

public class Main {
  public static void main(String[] args) {
    var imageView = new ImageView(new Image());
    imageView.apply(new VividFitler());
  }
}

// Applying Vivid Filter
```

## 2-Solution

- we have an existing class, but the interface of this class does not match the form that we expect
- we use the adapter pattern to convert the interface of this class to a different form

<img decoding="async" src="Adapter Pattern-2-Solution-0.png" width="400px" style="display:block;">
<img decoding="async" src="Adapter Pattern-2-Solution-1.png" width="400px" style="display:block;">

## 3-Implementation

- 方法一 composition
- CaramelFilter is composed by Caramel object

<img decoding="async" src="Adapter Pattern-3-Implementation-1.png" width="400px" style="display:block;">

```Java
public class Main {
  public static void main(String[] args) {
    var imageView = new ImageView(new Image());
    imageView.apply(new CaramelFilter(new Caramel()));
  }
}

// Applying Caramel Filter
```

- 方法二 inheritance，参考 demo 代码
- 使用 CaramelAdapter extends Caramel implements Filter 来实现 inheritance
- Favor Composition Over Inheritance

## 4-Exercise

<img decoding="async" src="Adapter Pattern-4-Exercise.png" width="400px" style="display:block;">

# Decorator Pattern

## 1-The Problem

- 使用这个 pattern to add additional behavior to an object
- implement a class for storing data in cloud
- encrypt 加密 data before storing it to the cloud，比如说客户的信用卡号码，我们不应该将它们直接存储成 plaintext 纯文本
- 不应该在 write 中实现加密功能，因为不是每次往 cloud 上 write 数据，都需要加密的
- 过了两天，manager 又说，我们需要 compress data before storing it to the cloud
- 我们甚至需要一个 CompressedAndEncryptedCloudStream extends CloudStream

- CloudStream

<img decoding="async" src="Decorator Pattern-1-The Problem-1.png" width="400px" style="display:block;">

- EncryptCloudStream

<img decoding="async" src="Decorator Pattern-1-The Problem-2.png" width="400px" style="display:block;">

- Main

<img decoding="async" src="Decorator Pattern-1-The Problem-3.png" width="400px" style="display:block;">

- CompressedCloudStream

<img decoding="async" src="Decorator Pattern-1-The Problem-4.png" width="400px" style="display:block;">

## 2-Solution

- FAVOR composition OVER inheritance

<img decoding="async" src="Decorator Pattern-2-Solution-1.png" width="400px" style="display:block;">

<img decoding="async" src="Decorator Pattern-2-Solution-2.png" width="400px" style="display:block;">

## 3-Implementation

```Java
public class Main{
  public static void main(String[] args) {
    storeCreditCard(new EncryptedCloudStream(new CompressedCloudStream(new CloudStream())));
  }
  public static void storeCreditCard(Stream stream) {
    stream.write("1234-1234-1234-1234");
  }
}
```

## 4-Exercise

<img decoding="async" src="Decorator Pattern-4-Exercise.png" width="400px" style="display:block;">

# Facade Pattern 正面

## 1-The Problem

- provide a simple interface to a complex system
- 我们有一个 mobil app，其中有一个功能是，push notification to our users
- 有一个问题是，每一次，我们想 send a push notification to our users, we have to follow all these steps

```Java
public class Main{
  public static void main(String[] args) {
    var server = new NotificationServer();
    var connection = server.connect("ip");
    var authToken = server.authenticate("appID", "key");
    var message = new Message("Hello World");
    server.send(authToken, message, "target");
    connection.disconnect();
  }
}
```

## 2-Solution

- 第二个问题是，耦合问题。main 需要跟 4 个类耦合，如果其中任何一个改变，都需要修改 Main，而且任何需要 send notice 的类，都与 main 一样，皆是如此

<img decoding="async" src="Facade Pattern-2-Solution-1.png" width="400px" style="display:block;">

<img decoding="async" src="Facade Pattern-2-Solution-3.png" width="400px" style="display:block;">
<img decoding="async" src="Facade Pattern-2-Solution-2.png" width="300px" style="display:block;">

## 3-Implementation

```Java
public class Main{
  public static void main(String[] args) {
    var server = new NotificationServer();
    server.send("Hello World", "target")
  }
}
```

## 4-Exercise

<img decoding="async" src="Facade Pattern-4-Exercise.png" width="500px" style="display:block;">

# Flyweight Pattern

## 1-The Problem

- 当有很多 object 的时候，这些 object 占用很多内存，使用这个 pattern
- 使用这个 pattern，我们可以减少对内存的消耗
- google map
- point 这个类花了很多内存，会有成千上万的 points
- icon 会占用很多内存，一个 20KB，1000 个就 20MB

<img decoding="async" src="Flyweight Pattern-1-The Problem-0.png" width="200px" style="display:block;">

<img decoding="async" src="Flyweight Pattern-1-The Problem-1.png" width="500px" style="display:block;">
<img decoding="async" src="Flyweight Pattern-1-The Problem-2.png" width="400px" style="display:block;">

<img decoding="async" src="Flyweight Pattern-1-The Problem-3.png" width="500px" style="display:block;">

<img decoding="async" src="Flyweight Pattern-1-The Problem-main.png" width="400px" style="display:block;">

## 2-Solution

- 我们可以将 PointIcon 保存在统一的位置，复用他们
- 为了确保上述，我们不应该直接新建 PointIcon object，我们应该引入一个新的类 PointIconFactory，专门用来产生 PointIcon
- 当 call this method(getPointIcon)的时候，如果这个 factory object 有一个 cafe icon，他就会 simply 返回它。如果没有，他就去 create 它，并且把它保存在某处（缓存或者 pool），然后将它返回
- 有了 PointIconFactory 我们就可以保证，将一个 given icon 比如说 cafe icon 保存在内存中一个单一的位置
- PointIcon 就是 FLYWEIGHT

<img decoding="async" src="Flyweight Pattern-2-Solution.png" width="300px" style="display:block;">

## 3-Implementation

<img decoding="async" src="Flyweight Pattern-3-Implementation.png" width="500px" style="display:block;">

- 结果是：CAFE at (1,2)

# Bridge Pattern

## 1-The Problem

- 每一次添加一个新品牌，都需要添加两个新类
- basic remote control(turnOn, TurnOff)
- advanced remote control(setChannel)
- Movie Remote Control(play, pause, rewind)

<img decoding="async" src="Bridge Pattern-1-The Problem-1.png" width="400px" style="display:block;">

<img decoding="async" src="Bridge Pattern-1-The Problem-2.png" width="400px" style="display:block;">

<img decoding="async" src="Bridge Pattern-1-The Problem-2-2.png" width="500px" style="display:block;">

<img decoding="async" src="Bridge Pattern-1-The Problem-3.png" width="400px" style="display:block;">

## 2-Solution

<img decoding="async" src="Bridge Pattern-2-Solution-1.png" width="400px" style="display:block;">

<img decoding="async" src="Bridge Pattern-2-Solution-2.png" width="400px" style="display:block;">

## 3-Implementation

<img decoding="async" src="Bridge Pattern-3-Implementation.png" width="400px" style="display:block;">

# Proxy Pattern 代理模式

## 1-Problem

- 我们现在只有三本 Ebook 在图书馆中，以后有成百上千本书怎么办
- 当程序启动的时候，我们必须从磁盘中 load 所有的 Ebooks，并且将他们存在内存中
- 用户不会将所有的 book 都打开，她只会打开其中一本
- 使用代理模式，我们可以 create an object that simulates a real ebook.在真的需要的时候，才会 load 这本书

<img decoding="async" src="Proxy Pattern-1-Problem-1.png" width="300px" style="display:block;">

<img decoding="async" src="Proxy Pattern-1-Problem-2.png" width="400px" style="display:block;">

<img decoding="async" src="Proxy Pattern-1-Problem-3.png" width="400px" style="display:block;">

<img decoding="async" src="Proxy Pattern-1-Problem-4.png" width="300px" style="display:block;">

<img decoding="async" src="Proxy Pattern-1-Problem-5.png" width="200px" style="display:block;">

## 2-Solution

- 问题是，create ebook is costly.每一次 create eBook，我们都需要将这本 eBook 从 disk 中读取，将它加载到内存中

<img decoding="async" src="Proxy Pattern-2-Solution-1.png" width="400px" style="display:block;">

<img decoding="async" src="Proxy Pattern-2-Solution-2.png" width="400px" style="display:block;">

- 在我们这个例子中，realSubject.equest()这个位置，我们会判断一下，是因为我们想要实现 lazy initialization， 但是这个判断在代理模式中，不是必须的
- 代理模式的重点是：代理类，看起来很像 RealSubject，RealSubject 和 Proxy 都实现 Subject 接口. 但是在代理类中，我们将 request 指向 RealSubject
- 在代理类的 request 中，我们可以执行，login, authentication, lazy initialization

## 3-Implementation

- Loading the ebook a
- Logging
- Showing the ebook a
- Loading the ebook b
- Logging
- Showing the ebook b

<img decoding="async" src="Proxy Pattern-3-Implementation-1.png" width="400px" style="display:block;">

## 4-Exercise

<img decoding="async" src="Proxy Pattern-4-Exercise.png" width="400px" style="display:block;">
