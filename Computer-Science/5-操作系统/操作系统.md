[王道考研](https://www.bilibili.com/video/BV1YE411D7nH/?spm_id_from=333.337.search-card.all.click)
https://hit-alibaba.github.io/interview/basic/arch/Concurrency.html
https://javabetter.cn/sidebar/sanfene/os.html
[GitHub 笔记](https://github.com/glshi/books/blob/master/docs/course/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%A6%82%E8%BF%B0.md)
[笔记二](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E6%A6%82%E8%BF%B0.md#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8)

# 一 概述

## 1.1 操作系统的概念，功能

- 硬件只能懂二进制指令 0101，硬件对外暴露了不友好的交互接口。操作系统，对外暴露美丽的友好的交互接口
- 早期的操作系统提供，交互式/联机命令接口（用户说一句，系统做一句），批处理/脱机命令接口（用户说一堆，系统跟着做一堆）
- 现在的操作系统提供，GUI 接口
- 给程序员使用的命令接口：程序接口，可以在程序中，进行系统调用/广义指令，来使用程序接口

## 1.3.1 操作系统的运行机制

- 普通程序员写的是"应用程序"
- 实现操作系统的人写的是“内核程序”，很多内核程序组成了“操作系统内核”/“内核”
  - docker 中只需要 linux 内核
  - 操作系统的功能未必都在内核中，如 GUI
- 特权指令（将内存清空）/非特权指令
- 为了让 CPU 区分指令类型，CPU 有两种状态，内核态/用户态。程序状态寄存器会记录状态
  - 内核态，此时运行的是内核程序，可以执行特权指令
  - 用户态，此时运行的是应用程序，只能执行非特权指令

## 1.4 操作系统体系结构

- 宏内核
- 微内核

# 二 CPU 管理/进程管理

## 进程地址空间

进程是一个实体。每一个进程都有它自己的地址空间，一般情况下，包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。
文本区域存储处理器执行的代码；
数据区域存储变量和进程执行期间使用的动态分配的内存；
堆栈区域存储着活动过程调用的指令和本地变量。

### 例子：计算两个数的和的程序

假设我们有一个简单的 C 程序，它计算两个数的和并输出结果：

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int a = 5; // 定义变量a，存储在数据区域
    int b = 10; // 定义变量b，存储在数据区域
    int sum = 0; // 定义变量sum，存储在数据区域

    sum = a + b; // 执行加法操作，结果存储在数据区域
    printf("Sum: %d\n", sum); // 打印结果

    return 0;
}
```

### 进程各个区域的解释

1. **文本区域（Text Region）**：

   - **内容**：存储程序的代码。
   - **例子中的代码**：`int main() { ... }` 中的所有指令。
   - **作用**：处理器读取并执行这些指令。例如，执行加法操作和打印结果的代码。

2. **数据区域（Data Region）**：

   - **内容**：存储程序中的全局变量、静态变量和动态分配的内存。
   - **例子中的变量**：`int a = 5;`、`int b = 10;`、`int sum = 0;`。
   - **作用**：用于存储程序运行过程中需要保持的数据。例如，变量`a`、`b`和`sum`存储在数据区域，保持它们的值以供计算和输出。

3. **堆栈区域（Stack Region）**：
   - **内容**：存储函数调用的相关信息（如函数参数、局部变量、返回地址）。
   - **例子中的堆栈操作**：
     - 当`main`函数被调用时，堆栈中存储了返回地址。
     - 局部变量（如在其他函数中定义的变量）也会存储在堆栈中（虽然这个例子中没有额外的函数调用）。
   - **作用**：用于管理函数调用的顺序和数据。例如，如果程序中有嵌套的函数调用，堆栈会存储每个函数的返回地址和局部变量，以便函数执行完毕后能够正确返回。

### 更复杂的例子

对于一个更复杂的程序，假设我们增加了一个函数用于动态分配内存：

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int *arr;
    int size = 5;

    // 动态分配内存
    arr = (int *)malloc(size * sizeof(int));

    // 检查内存分配是否成功
    if (arr == NULL) {
        fprintf(stderr, "Memory allocation failed\n");
        return 1;
    }

    // 使用动态分配的内存
    for (int i = 0; i < size; i++) {
        arr[i] = i * 10; // 初始化数组
    }

    // 打印数组元素
    for (int i = 0; i < size; i++) {
        printf("arr[%d] = %d\n", i, arr[i]);
    }

    // 释放动态分配的内存
    free(arr);

    return 0;
}
```

### 更新后的进程各个区域的解释

1. **文本区域（Text Region）**：

   - 存储所有程序的代码，包括`malloc`和`free`等库函数的调用指令。

2. **数据区域（Data Region）**：

   - 存储全局变量和静态变量（本例中没有全局和静态变量）。

3. **堆区域（Heap Region）**：

   - **内容**：动态分配的内存。
   - **例子中的代码**：`arr = (int *)malloc(size * sizeof(int));` 动态分配了一个整数数组，内存存储在堆区域。
   - **作用**：用于在程序运行时动态分配和释放内存，例如存储用户输入的数据或临时需要的大块内存。

4. **堆栈区域（Stack Region）**：
   - 存储函数调用的相关信息和局部变量。
   - **例子中的局部变量**：`int size`、`int i`等都存储在堆栈区域。
   - **作用**：管理函数调用，包括存储每个函数的局部变量和返回地址。

通过这个例子，可以清楚地看到进程的各个区域是如何在程序运行中发挥作用的。理解这些概念有助于编写高效且安全的代码，特别是在需要进行内存管理和多任务处理的复杂应用中。

## 2.3.1 进程同步，进程互斥

- 进程同步：为了完成某种任务而建立的两个或多个进程，他们需要在某些位置上协调他们的工作次序而产生的制约关系
  - 并发性带来了异步性，有时需要通过进程同步解决这种异步问题
  - 有的进程之间需要相互配合的完成工作，各个进程的工作推进需要遵循一定的先后顺序
  - 异步性，各个并发执行的进程以各自独立的，不可预知的速度向前推进
  - 如何解决异步问题，就是进程同步所讨论的内容
- 进程互斥：对临界资源的访问，需要互斥的进行，同一时间段内只能允许一个进程访问该资源
  - 资源共享方式
    - 互斥共享
    - 同事共享

## 为何要利用并发和异步编程

- I/O 密集型任务，避免等待，提高 CPU 利用率
  - 即使是单核 CPU，并发编程依然可以提升效率。比如说 I/O 密集型任务， 在等待期间，多线程可以利用闲置的 CPU 开始别的任务，而不是一起等待
- 多核资源利用率，4 张图片，每个处理时间 2 秒，单线程处理 8 秒，如果计算机有足够的核心可以同时处理所有线程，多线程处理 2 秒
- 单线程模式：服务器一次只能处理一个请求，5×2 秒 = 10 秒。多线程模式：服务器可以同时处理多个请求。总处理时间接近于单个请求的处理时间（大约 2 秒）

# 三 内存管理

# 四 文件系统/外存管理

# 五 设备管理/ I/O 管理

# 问题

- linux + shell
- 提升代码内存，cpu 使用率
  - 并发和并行处理
    a. 多线程：对于 I/O 密集型任务，使用多线程可以让程序在等待 I/O 操作（如读写文件、网络请求等）完成时执行其他任务。
    b. 多进程：对于 CPU 密集型任务，使用多进程可以利用多核 CPU 的能力，让不同的进程在不同的 CPU 核心上并行运行。
  - 减少内存占用
    a. 数据压缩：在处理大量数据时，考虑在内存中压缩数据，尽管这可能会增加 CPU 的使用率。
    b. 适时释放资源：确保不再需要的数据被及时释放，避免内存泄漏。
  - 使用性能分析工具
    a. 分析并优化热点：使用性能分析工具（如 Python 的 cProfile、line_profiler 或内存分析工具如 memory_profiler）来识别和优化代码中的性能瓶颈和内存使用高峰。
  - 异步编程
    异步 I/O：对于网络应用和 I/O 密集型应用，使用异步编程模式可以提高应用的响应性和吞吐量。
  - 使用流式处理：对于某些操作，你可能可以使用流式处理技术，即一次只读取并处理数据的一小部分，然后继续下一部分，而不是一次性将所有数据加载到内存中。
- GPU 计算
- 安装 c++编译器，bin 是什么，exe 是什么，zip 怎么安装的[安装 c++编译器](https://zhuanlan.zhihu.com/p/76613134)
